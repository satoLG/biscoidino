import { inject } from '@vercel/analytics';
import './style.css?v=8'

// BISCOIDINO - Main Application
class BiscoidinoApp {
  private app: HTMLElement;
  private splashScreen: HTMLElement;
  private typewriterRunning: boolean = false;
  private activeEventListeners: Array<{element: any, event: string, handler: any, options?: any}> = [];

  constructor() {
    inject();
    this.app = document.querySelector<HTMLDivElement>('#app')!;
    this.splashScreen = document.querySelector<HTMLDivElement>('#splash-screen')!;
    this.initializeSplashScreen();
    this.initializePWA();
  }

  private initializeSplashScreen(): void {
    // Show splash screen for 3 seconds then transition to main content
    setTimeout(() => {
      this.hideSplashScreen();
    }, 3000);
  }

  private hideSplashScreen(): void {
    // Add fade out animation to splash screen
    this.splashScreen.classList.add('fade-out');
    
    // After fade out animation completes, hide splash and show app
    setTimeout(() => {
      this.splashScreen.style.display = 'none';
      this.app.classList.remove('hidden');
      this.app.classList.add('visible');
      this.render();
    }, 500); // Match the CSS animation duration
  }

  private initializePWA(): void {
    console.log('üîß Initializing PWA infrastructure...');
    
    // Register service worker for PWA functionality
    this.registerServiceWorker();
    
    // Listen for app installation (for logging purposes)
    window.addEventListener('appinstalled', () => {
      console.log('üéâ PWA was installed successfully via native browser prompt');
      localStorage.setItem('pwa-installed', 'true');
    });
    
    console.log('‚úÖ PWA infrastructure ready - install via browser menu');
  }

  private async registerServiceWorker(): Promise<void> {
    if ('serviceWorker' in navigator) {
      try {
        const registration = await navigator.serviceWorker.register('/sw.js', {
          scope: '/'
        });
        
        console.log('‚úÖ Service Worker registered successfully:', registration.scope);
        
        // Listen for updates
        registration.addEventListener('updatefound', () => {
          console.log('üÜï New service worker available');
        });
        
      } catch (error) {
        console.error('‚ùå Service Worker registration failed:', error);
      }
    } else {
      console.log('‚ùå Service Worker not supported');
    }
  }

  public async showNativeInstallPrompt(): Promise<void> {
    console.log('‚ÑπÔ∏è PWA Install: Use your browser\'s native "Add to Home Screen" or "Install" option');
  }

  private render(): void {
    this.app.innerHTML = `
      <div class="container">
        <header class="header">
          <div class="logo">
            <h1 class="trademark-name"><img src="/biscoidino_logo.png" alt="BISCOIDINO" class="header-logo"> BISCOIDINO</h1>
          </div>
          <nav class="nav">
            <a id="home-tab" href="#home" class="nav-link active">
              <img src="/biscoidino_logo.png" alt="BISCOIDINO" class="header-logo">
              <svg class="nav-icon" viewBox="-1 0 160 160" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g clip-path="url(#clip0)"> <path d="M151.886 66.6515C150.949 65.8042 149.98 64.9277 149.056 64.0429C141.33 56.6493 133.607 49.2525 125.886 41.8532C112.662 29.1867 99.4339 16.5271 86.2013 3.87434C81.4332 -0.681452 79.358 -0.64129 74.5155 4.10365L71.0912 7.45858C54.2522 23.9548 36.8401 41.0132 19.6554 57.7297C16.005 61.2801 12.1885 64.7904 8.49739 68.1815C6.71115 69.8223 4.92858 71.4683 3.14967 73.1188C2.38276 73.8314 0.0484318 76.0066 2.05713 78.3451C3.40229 79.9114 5.19714 79.8162 7.39128 78.0633C8.82108 76.9193 10.2496 75.7313 11.6316 74.5783C12.5232 73.8346 13.4167 73.0949 14.3122 72.3571C14.7037 72.0332 15.1114 71.7404 15.7304 71.2934L15.9332 71.1464C15.9332 72.5268 15.9423 73.867 15.9488 75.1729C15.9656 78.746 15.9811 82.1216 15.9171 85.4758C15.7943 91.8557 15.6561 98.2349 15.5023 104.615C15.3124 112.937 15.1146 121.543 14.9757 130.008C14.8866 135.384 14.8355 141.095 15.2665 146.655C15.7317 152.657 18.0272 154.832 24.3647 155.271C28.2141 155.539 32.1282 155.842 35.9136 156.137C43.4011 156.72 51.1432 157.32 58.7742 157.671C77.001 158.509 95.5154 159.145 113.804 159.562C114.45 159.576 115.104 159.584 115.765 159.584C121.112 159.543 126.452 159.157 131.75 158.427C139.692 157.395 142.568 154.615 143.585 146.983C144.861 137.412 145.721 127.332 146.214 116.166C146.65 106.29 146.813 96.5948 146.986 86.3315C147.051 82.4532 147.123 78.5433 147.198 74.6016C147.872 75.2383 148.454 75.7883 149.067 76.3188C151.498 78.4254 154.113 78.6068 155.889 76.7917C156.29 76.3946 156.606 75.9205 156.82 75.3984C157.034 74.8756 157.14 74.3153 157.132 73.7511C157.037 72.1828 156.326 70.7169 155.154 69.6746C154.087 68.6427 152.968 67.6277 151.886 66.6515ZM62.1442 96.701L92.606 93.8158L93.5616 151.767L60.9541 150.51L62.1442 96.701ZM101.62 102.118C101.612 99.1814 101.454 96.2048 101.302 93.3268C101.264 92.5928 101.226 91.8583 101.189 91.1243C101.086 89.0625 100.52 87.6102 99.4585 86.6832C98.3789 85.7407 96.8147 85.3702 94.6774 85.5639C82.3119 86.6592 70.9762 87.5953 60.0231 88.4244C55.3784 88.7762 53.8129 90.4675 53.8168 95.1282C53.8362 115.043 53.831 130.32 53.7987 144.664C53.7722 145.92 53.6816 147.174 53.5273 148.421C53.4795 148.879 53.4298 149.348 53.3839 149.832L22.5996 147.912C22.544 147.435 22.4833 146.97 22.4226 146.514C22.233 145.3 22.125 144.075 22.0995 142.846C22.1305 137.491 22.1932 132.047 22.254 126.781C22.3257 120.498 22.4 114.001 22.4219 107.611C22.4433 101.591 22.4271 95.4715 22.4122 89.5535C22.3942 82.3982 22.3754 74.9993 22.4206 67.7235C22.4185 66.417 22.8789 65.1525 23.7199 64.1542C37.6179 50.7745 51.8249 37.2502 65.5652 24.1717L71.977 18.0672C74.0296 16.1128 76.0958 14.1741 78.206 12.1932L80.8162 9.74069C82.6718 11.5234 84.5222 13.2968 86.3667 15.0614C90.6348 19.1475 95.0483 23.3738 99.3318 27.5513C104.786 32.8716 110.232 38.1994 115.67 43.535C122.602 50.3262 129.769 57.3473 136.845 64.2273C138.3 65.6435 138.964 66.7758 138.557 69.0366C138.316 70.8581 138.321 72.7036 138.575 74.5238C138.708 75.7002 138.773 76.8837 138.769 78.0678L138.699 80.7885C138.418 91.7624 138.128 103.109 137.597 114.254C137.279 120.91 136.757 127.673 136.257 134.213C136.03 137.162 135.805 140.112 135.594 143.061L135.584 143.195C135.565 143.47 135.545 143.746 135.51 144.019C134.77 149.882 134.258 150.408 128.672 151.052C119.701 152.092 110.658 152.374 101.64 151.894L101.644 139.013C101.649 126.899 101.655 114.374 101.621 102.118H101.62Z" fill="#000000"></path> </g> <defs> <clipPath id="clip0"> <rect width="157" height="160" fill="white" transform="translate(0.777344)"></rect> </clipPath> </defs> </g>
              </svg>
            </a>
            <a id="menu-tab" href="#menu" class="nav-link">
              <svg viewBox="0 -1.5 159 159" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g clip-path="url(#clip0)"> <path d="M151.667 72.7118C150.186 72.6663 148.722 73.4099 147.309 74.9563C142.202 80.5411 135.352 82.9058 126.373 82.1836C118.732 81.5694 113.298 78.7516 109.766 73.5685C108.809 72.1483 108.164 70.5389 107.874 68.8495C107.584 67.1595 107.655 65.4266 108.083 63.7667C108.375 62.4926 108.941 61.2978 109.74 60.2656C110.54 59.2335 111.554 58.3891 112.712 57.7907C112.842 57.7272 112.947 57.6232 113.013 57.4942C113.079 57.3653 113.101 57.2184 113.077 57.0756C112.207 52.0557 111.013 51.0306 106.336 51.2523C105.976 51.2698 105.616 51.3173 105.258 51.3608C104.954 51.3985 104.65 51.4375 104.346 51.4557C97.5958 51.86 88.7867 51.8808 80.4781 48.4085C71.9092 44.8277 67.8128 38.6941 67.954 29.6591C67.9818 27.1485 68.2641 24.6474 68.7958 22.1939C70.2171 16.1166 72.9277 10.4185 76.7437 5.48883L76.8253 5.37902C77.7584 4.13167 78.4441 3.11128 78.0932 2.27343C77.7778 1.70534 77.3304 1.2227 76.7877 0.867421C76.2451 0.512143 75.6247 0.294789 74.9804 0.234242C74.5738 0.222542 74.1639 0.20701 73.7533 0.19076C71.2279 0.0952101 68.6203 -0.00423717 66.2076 0.664615C39.5623 8.07139 21.5334 22.5254 11.0898 44.8516C2.27099 63.7055 -0.595437 79.8384 2.06855 95.6243C6.21799 120.209 19.324 137.415 41.0225 146.767C54.7614 152.688 68.5232 155.662 82.1105 155.662C87.2993 155.662 92.4789 155.227 97.5952 154.358C117.748 150.94 133.606 141.657 144.728 126.765C153.629 114.845 158.033 100.04 158.189 81.5044C158.209 79.2144 156.894 76.7139 155.664 75.1344C154.445 73.5796 153.102 72.7671 151.667 72.7118ZM78.3658 56.8668C84.057 59.0768 90.4042 60.2418 97.77 60.4323C98.8125 60.4583 99.8551 60.4524 100.957 60.4453L101.782 60.4399C101.774 60.4769 101.767 60.5139 101.759 60.5497C101.659 61.0469 101.581 61.4403 101.475 61.8173C98.8656 71.0914 101.589 79.191 109.141 84.6237C119.451 92.0396 131.352 93.322 144.511 88.4347C145.136 88.2026 145.735 87.9257 146.428 87.604C146.501 87.5702 146.576 87.539 146.651 87.5C146.558 92.9021 145.695 98.2627 144.085 103.418C137.757 124.495 122.627 138.037 99.1149 143.669C80.8899 148.033 61.913 145.956 42.7141 137.494C25.439 129.882 14.7071 115.756 10.8173 95.5086C9.18096 86.9416 9.41349 78.1205 11.4987 69.6523C16.4789 49.0885 23.8983 35.4443 35.5567 25.4116C45.6978 16.6847 56.1393 10.7682 67.4767 7.32519C67.5674 7.29789 67.6581 7.27371 67.7604 7.24901C63.5874 13.1886 61.0233 20.1145 60.3188 27.3479C58.9363 41.1214 65.5145 51.8813 78.3625 56.8668H78.3658Z" fill="#000000"></path> <path d="M89.7106 131.093H89.8252C96.6419 131.093 102.049 125.035 102.156 117.247C102.225 112.137 96.2553 106.059 90.9487 105.838C87.9014 105.698 84.5581 107.155 81.7853 109.803C78.8623 112.591 77.0984 116.25 77.0661 119.59C77.0039 125.97 82.5611 131.021 89.7106 131.093ZM85.9387 118.542C86.0067 116.222 88.8986 113.061 90.4941 113.061H90.5C91.312 113.205 92.0405 113.648 92.5442 114.303C93.3485 115.092 93.8309 116.152 93.8976 117.278C93.6697 119.987 91.8436 121.938 89.6517 121.828C87.3063 121.706 85.883 120.445 85.9387 118.542Z" fill="#000000"></path> <path d="M53.2818 83.6222C53.2591 86.9249 54.2529 89.6854 56.1606 91.6055C58.1 93.5607 60.9258 94.5923 64.3371 94.5923H64.3845C67.9313 94.5825 70.9359 93.4268 73.0754 91.25C75.4383 88.845 76.6634 85.3083 76.6168 81.0196C76.552 74.7673 71.2351 70.7704 63.0919 70.8478C57.2751 70.9004 53.3323 76.0335 53.2818 83.6222ZM60.8158 83.6125C60.7827 81.3069 61.3339 79.3147 62.2547 78.4125C62.3899 78.2649 62.5532 78.1466 62.7347 78.0634C62.9161 77.9809 63.1121 77.9354 63.3114 77.9295H63.3613C66.317 78.0433 68.7621 79.9361 68.8133 82.15C68.8852 85.2557 67.2689 87.2401 64.5944 87.3272C63.2462 87.3747 62.3039 87.1231 61.7263 86.5693C61.1345 86.0025 60.8358 85.0353 60.8158 83.6125Z" fill="#000000"></path> <path d="M36.2059 92.4684C34.6864 92.443 33.1773 92.7225 31.7666 93.29C30.356 93.8574 29.0722 94.7011 27.9905 95.7723C27.1225 96.6076 26.4297 97.6079 25.9527 98.7162C25.4757 99.8238 25.2243 101.016 25.2131 102.223C25.241 107.033 28.1103 109.902 32.8872 109.902H32.8926C39.0591 109.902 43.5484 105.875 43.5685 100.336C43.5833 95.9595 40.3488 92.5041 36.2059 92.4684ZM30.4934 101.676C30.5199 101.26 30.7086 100.872 31.0186 100.594C31.7529 99.8595 33.4144 99.0899 35.9036 99.0711C35.9742 99.1361 36.0518 99.2102 36.1347 99.2856C36.5323 99.6489 37.1332 100.196 37.2012 100.677C37.2304 100.95 37.199 101.227 37.1095 101.487C37.0199 101.748 36.8746 101.985 36.6833 102.183C36.152 102.716 35.5202 103.139 34.8248 103.425C34.1293 103.711 33.3838 103.856 32.6321 103.851C32.054 103.904 31.4775 103.735 31.0192 103.377C30.627 102.902 30.4379 102.291 30.4934 101.676Z" fill="#000000"></path> <path d="M45.2752 37.0415C42.9654 35.5705 39.9235 35.5571 36.928 37.0059C33.8949 38.4736 32.8653 41.136 31.8707 43.7106C31.736 44.059 31.6021 44.4075 31.4622 44.7507C31.0922 45.6074 30.8984 46.5303 30.8931 47.464C30.8877 48.3978 31.0707 49.323 31.4309 50.184C31.8514 51.1142 32.4522 51.951 33.1983 52.6456C33.9445 53.3402 34.8208 53.8787 35.7765 54.2296C37.0542 54.7511 38.4185 55.0256 39.7977 55.0393C41.5205 55.0531 43.2073 54.5443 44.6369 53.579C47.2918 51.7837 48.8362 48.5381 48.8724 44.6739C48.9048 41.301 47.5947 38.5189 45.2752 37.0415ZM43.3541 45.5566C43.2984 48.2287 42.0117 49.6789 39.7427 49.6301C39.206 49.635 38.6737 49.5329 38.1766 49.3299C37.6795 49.1268 37.2278 48.8269 36.8471 48.4472C36.6142 48.2111 36.4317 47.9294 36.3115 47.6199C36.1912 47.3103 36.1356 46.9794 36.1477 46.6474C36.2524 45.5112 36.7651 44.452 37.5904 43.6675C38.4157 42.8829 39.4971 42.4265 40.633 42.3833H40.7032C41.4418 42.3106 42.1791 42.5333 42.7552 43.0028C43.1917 43.4604 43.3819 44.2714 43.3541 45.5578V45.5566Z" fill="#000000"></path> </g> <defs> <clipPath id="clip0"> <rect width="158" height="156" fill="white" transform="translate(0.777344)"></rect> </clipPath> </defs> </g>
              </svg>
            </a>
            <a id="about-tab" href="#about" class="nav-link">
              <svg viewBox="0 -1 155 155" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g clip-path="url(#clip0)"> <path d="M153.697 1.19123C151.441 -0.434315 149.018 0.0195515 146.884 0.416577C146.409 0.505665 145.936 0.594724 145.468 0.659925C125.613 3.40954 106.067 8.02965 87.0922 14.4577C75.3992 18.4506 63.9207 22.2503 52.9783 25.7519C48.8196 27.0818 46.1385 29.5124 44.5342 33.4C39.5958 45.3611 36.638 55.6986 35.2163 65.9309C35.124 66.5952 35.0499 67.264 34.9752 67.9419C34.8183 69.8321 34.4921 71.7049 34.0005 73.5377C33.5456 73.0987 33.1012 72.6732 32.6724 72.2588C31.2805 70.9147 29.9659 69.6462 28.6156 68.4583C26.0061 66.164 24.2115 66.0052 21.229 67.8128C20.218 68.3867 19.2773 69.0748 18.4259 69.8637C13.184 75.018 7.94998 80.2238 2.86995 85.3374C2.0203 86.0791 1.39553 87.0417 1.06621 88.1172C0.736893 89.1921 0.71597 90.3373 1.00561 91.4238C1.02824 91.5336 1.07862 91.6349 1.15188 91.7201C2.28121 93.0377 3.42994 94.4244 4.60801 95.8447C7.3371 99.1371 10.1552 102.535 13.258 105.744C22.9398 115.763 33.6394 126.576 46.9211 139.774C50.0505 142.884 53.3903 145.878 56.6204 148.772C58.109 150.107 59.5977 151.442 61.0721 152.792C61.196 152.905 61.3586 152.968 61.527 152.967H65.5308C65.6629 152.967 65.7921 152.929 65.9019 152.856C66.0117 152.783 66.0975 152.679 66.1481 152.558C66.2066 152.416 66.2547 152.261 66.3015 152.106C66.3372 151.956 66.3918 151.812 66.4646 151.676C69.1703 149.314 71.8825 146.958 74.6012 144.61C77.9106 141.744 81.2155 138.871 84.5151 135.991C86.2923 134.434 88.1422 132.441 88.3846 129.467C88.3885 129.419 88.3872 129.37 88.3807 129.322C88.0096 126.675 86.2455 125.052 84.5391 123.481C83.2525 122.295 82.0303 121.169 81.3675 119.636L81.6859 119.474C82.1862 119.206 82.7028 118.968 83.2331 118.764C86.4424 117.62 89.6562 116.486 92.8746 115.363C99.8033 112.933 106.968 110.42 113.951 107.771C118.045 106.218 121.937 104.01 125.699 101.876L125.899 101.763C128.933 100.042 130.838 97.19 131.564 93.2889C132.149 90.1417 132.897 86.9081 133.789 83.6789C141.891 54.3559 148.125 31.9248 154.002 10.9503C155.054 7.2008 155.031 4.28159 153.931 1.48627C153.883 1.36768 153.801 1.26525 153.697 1.19123ZM90.2124 76.0457C88.4586 76.5867 86.5613 76.4337 84.9186 75.6177C83.2753 74.8017 82.0134 73.3859 81.3967 71.6674C79.8931 67.8754 81.3415 64.3957 85.0863 62.8025C87.035 61.9822 89.1059 61.4832 91.2164 61.3254C91.4789 61.306 91.7329 61.2964 91.9786 61.2964C93.3015 61.2135 94.6063 61.6393 95.6219 62.4855C96.6239 63.4119 97.1275 64.878 97.1203 66.8431C97.1054 70.8243 94.0066 74.9508 90.2118 76.0483L90.2124 76.0457ZM132.81 16.9147C130.688 18.9689 128.683 20.9088 126.759 22.9998C124.744 25.1948 122.632 27.3723 120.589 29.4801C117.78 32.3813 114.871 35.3813 112.162 38.4691C108.926 42.1534 105.933 45.9215 102.764 49.9111C101.473 51.5354 100.171 53.1752 98.8397 54.824L98.1554 54.6192C97.3263 54.3706 96.466 54.1124 95.6083 53.8877C90.9051 52.7146 85.9446 53.1033 81.4845 54.9943C74.3849 57.8103 70.657 64.1459 71.7558 71.5293C72.1431 74.3601 73.2133 77.056 74.8755 79.3865C76.5376 81.7177 78.743 83.615 81.3025 84.9165C83.721 86.1037 86.3956 86.6834 89.0916 86.6046C91.7882 86.5259 94.4237 85.7912 96.7675 84.4646C100.465 82.5576 103.47 79.5486 105.359 75.8591C108.304 70.018 108.072 64.8909 104.648 60.1847C104.55 60.0498 104.446 59.9194 104.341 59.789C103.995 59.4059 103.738 58.9515 103.59 58.4584C103.557 58.3674 103.525 58.2777 103.488 58.188C103.488 58.1499 103.488 58.1111 103.483 58.073C103.475 57.9921 103.475 57.9107 103.483 57.8297C103.506 57.7291 103.553 57.6353 103.62 57.5559C116.658 44.6394 129.703 31.7292 143.257 18.3143C143.16 19.015 143.014 19.7083 142.821 20.3892C141.01 26.2742 139.19 32.1568 137.363 38.0371C134.4 47.5876 131.337 57.4642 128.382 67.1962C126.673 72.8256 125.044 78.8571 123.541 85.1243C123.126 87.0869 122.258 88.9261 121.005 90.4981C119.752 92.07 118.148 93.3308 116.32 94.181C112.968 95.8421 109.833 97.3443 106.739 98.7685C103.749 100.146 100.631 101.409 97.6181 102.632C90.0805 105.688 82.2922 108.846 75.5785 114.123L40.6478 79.5808C40.6894 79.1141 40.7129 78.6719 40.737 78.2503C40.7381 77.4014 40.8545 76.5563 41.0831 75.7384C44.8441 64.9316 48.7235 53.9446 52.4753 43.3198L55.4781 34.8138C60.7849 32.9843 66.1488 31.0825 71.3387 29.2426C93.5387 21.3705 116.474 13.2376 140.821 8.69536C138.165 11.7321 135.448 14.3608 132.809 16.914L132.81 16.9147ZM77.4122 128.884L63.0662 142.609C54.0341 135.572 15.2925 97.8601 9.8447 90.8015C13.1996 85.7828 20.0041 78.3058 24.1166 75.1141L24.2226 75.1787C24.5595 75.3679 24.8741 75.5938 25.1607 75.852C40.4425 90.9629 55.714 106.083 70.9754 121.212L71.7695 121.993C73.8481 124.033 75.9944 126.139 77.4116 128.884H77.4122Z" fill="#000000"></path> </g> <defs> <clipPath id="clip0"> <rect width="154" height="153" fill="white" transform="translate(0.777344)"></rect> </clipPath> </defs> </g>
              </svg>
            </a>
            <a id="gallery-tab" href="#gallery" class="nav-link">
              <svg viewBox="0 -0.5 157 157" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g clip-path="url(#clip0)"> <path d="M52.3816 53.2803C55.1411 55.8328 58.5193 56.971 63.3378 56.971C63.3609 56.9733 63.3841 56.9733 63.4071 56.971C63.5554 56.9573 63.7373 56.9443 63.9431 56.93C64.4894 56.8917 65.2377 56.8377 65.9725 56.7285C68.0872 56.4465 70.1236 55.7401 71.9607 54.6514C73.7984 53.5626 75.3985 52.1137 76.6666 50.391C77.8757 48.6838 78.7308 46.7497 79.18 44.7038C79.6293 42.6579 79.6636 40.5421 79.2817 38.4825C78.4758 33.7759 76.2393 30.7682 72.6442 29.5456C70.1922 28.7181 67.5946 28.4137 65.0189 28.6518C62.4429 28.8901 59.9447 29.6656 57.6843 30.9288C55.5114 32.1174 53.6139 33.7547 52.1166 35.7328C50.6193 37.711 49.5563 39.9853 48.9975 42.4058C48.0136 46.6334 49.1522 50.2935 52.3816 53.2803ZM65.6786 36.7853C65.8081 36.7853 65.9414 36.7853 66.0702 36.7853C68.2458 36.7853 69.9644 37.0531 70.7955 39.2416C71.2163 40.4323 71.2739 41.7219 70.9593 42.9453C70.6453 44.1688 69.9741 45.27 69.0323 46.1076C66.6754 48.2565 61.6374 48.8304 58.8631 47.2671C57.0875 46.2674 56.5464 45.0234 56.995 42.9739C57.9109 38.7892 60.6697 36.8243 65.6786 36.7853Z" fill="#000000"></path> <path d="M33.8781 154.127C35.4776 154.062 37.1353 153.997 38.7439 153.997C48.5751 154.046 57.5597 154.144 66.2106 154.297C80.0629 154.541 94.2058 154.841 108.241 155.188C109.387 155.25 110.526 155.41 111.645 155.665C112.195 155.774 112.746 155.882 113.294 155.97C113.329 155.976 113.364 155.979 113.399 155.979H120.022C120.055 155.979 120.087 155.976 120.119 155.971C121.447 155.776 122.779 155.598 124.111 155.422C126.991 155.042 129.97 154.649 132.865 154.034C146.162 151.213 156.827 137.547 156.639 123.568C156.513 114.22 156.538 104.712 156.562 95.5162C156.579 88.9168 156.595 82.0937 156.558 75.3818C156.522 69.2458 156.305 63.0122 156.096 56.9867L155.962 53.1159C155.914 51.6651 155.871 50.2135 155.832 48.761C155.703 43.9841 155.567 39.0447 155.098 34.208C154.602 29.443 153.714 24.7274 152.444 20.1096C148.91 6.97957 136.391 0.810472 125.556 0.525123C122.459 0.443873 119.324 0.663455 116.291 0.875355C114.009 1.03525 111.651 1.20035 109.34 1.23415C103.051 1.32645 96.6533 1.36416 90.4696 1.40316C82.3298 1.45256 73.9129 1.50465 65.6352 1.6769L64.3894 1.70357C52.5224 1.95057 40.2502 2.20529 28.2239 3.14194C15.2578 4.15139 6.66227 10.3836 2.67488 21.667C2.00579 23.383 1.61373 25.1952 1.51358 27.0353L1.44887 32.4667C1.25144 48.3338 1.04689 64.7419 1.09479 80.8815C1.11551 88.129 1.35888 95.4922 1.5945 102.613C1.72396 106.605 1.86313 110.731 1.95829 114.789C2.06315 119.209 2.10007 122.925 1.94019 126.69C1.35762 140.351 13.2278 153.461 26.8393 154.196C29.1897 154.322 31.5737 154.223 33.8781 154.127ZM9.50715 38.6314C9.42682 32.8611 10.7874 27.1627 13.4648 22.0564C15.909 17.5194 19.5086 14.6898 23.876 13.8747C30.7885 12.5845 37.5567 11.4106 44.3728 11.226C61.6953 10.7554 79.314 10.4798 96.351 10.2133C104.941 10.0784 113.531 9.9361 122.121 9.78621C126.717 9.70041 131.27 11.0564 136.473 14.049C142.152 17.3133 143.962 23.2004 144.984 28.5291C147.13 39.7195 148.078 49.1009 147.969 58.0514C147.925 61.5805 147.893 65.1183 147.872 68.666C147.628 68.4405 147.391 68.2065 147.136 67.9939C143.776 65.1918 140.32 62.3947 136.977 59.69C132.948 56.4296 128.782 53.06 124.761 49.6585C119.514 45.2229 116.452 45.3361 111.653 50.1448C100.239 61.5776 88.5646 73.2271 77.2737 84.4929L64.5085 97.2329L64.2826 97.0463C63.8664 96.7025 63.5285 96.4236 63.188 96.1493C61.404 94.7057 59.6228 93.2588 57.8445 91.8092C53.5076 88.2772 49.0166 84.6255 44.5385 81.1103C41.2891 78.5597 38.964 78.5948 35.9624 81.2325C27.163 88.9675 18.269 96.8539 9.62554 104.523C9.53751 84.1692 9.47284 61.6297 9.50715 38.6314ZM10.5163 112.695C12.1993 111.275 13.8788 109.851 15.5549 108.422C18.7228 105.729 21.9982 102.944 25.2547 100.253C28.7418 97.3694 32.3466 94.4723 35.833 91.6728C37.2687 90.5184 38.7105 89.3575 40.1582 88.1907C42.0937 89.7585 44.014 91.3133 45.9192 92.8532C50.8918 96.8734 55.5894 100.669 60.3483 104.586C64.1202 107.691 66.4106 107.576 69.7773 104.122C70.9055 102.963 72.0156 101.786 73.1251 100.612C74.5777 99.0704 76.0794 97.4773 77.5973 95.9595C89.0643 84.4981 100.746 72.8676 112.044 61.6199L116.97 56.7156C117.445 56.2411 117.957 55.7848 118.368 55.4156L118.407 55.3818C120.511 57.0354 122.6 58.6821 124.674 60.3218C130.877 65.2204 136.736 69.8477 142.814 74.4569C144.354 75.5281 146.045 76.3627 147.83 76.9334C147.792 89.1469 147.836 101.358 147.881 113.3C147.896 116.932 147.909 120.564 147.92 124.195C147.948 132.995 140.891 142.63 132.508 145.233C126.235 147.137 119.685 147.952 113.139 147.642C104.227 147.274 95.1651 146.843 86.4052 146.427C82.7583 146.254 79.1107 146.08 75.4625 145.907H75.4321L65.5827 145.903C60.2781 145.9 54.9739 145.898 49.6704 145.898C43.9145 145.898 38.1588 145.902 32.403 145.911H32.3343C25.8043 145.911 20.9075 144.263 16.9285 140.73C12.0485 136.394 9.75571 130.455 9.71234 122.038C9.69745 119.217 9.68321 116.33 9.66897 113.393C9.95443 113.165 10.2399 112.928 10.5163 112.695Z" fill="#000000"></path> </g> <defs> <clipPath id="clip0"> <rect width="156" height="156" fill="white" transform="translate(0.777344)"></rect> </clipPath> </defs> </g>
              </svg>
            </a>
            <a id="contact-tab" href="#contact" class="nav-link">
              <svg viewBox="0 -9 164 164" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g clip-path="url(#clip0)"> <path d="M51.3583 51.8096C52.2841 50.6252 53.2138 49.444 54.1474 48.2665C56.5303 45.2496 58.9935 42.1294 61.3143 38.9813C64.3123 34.9114 64.1078 33.0329 60.2747 29.4204C59.9559 29.1207 59.6195 28.839 59.2825 28.5586C59.0238 28.3409 58.7599 28.123 58.5064 27.895L55.5071 25.1821C52.6242 22.5748 49.6429 19.8786 46.7355 17.2034C44.5263 15.1711 42.3256 13.131 40.1333 11.0827C37.2051 8.35777 34.1773 5.53907 31.169 2.79866C27.8055 -0.269924 25.8799 -0.264639 22.5953 2.82074C19.466 5.75948 16.3062 8.7698 13.2506 11.6801C10.5184 14.2827 7.78144 16.88 5.03978 19.4727C3.83682 20.5913 2.87905 21.9473 2.22689 23.4542C1.57473 24.961 1.24233 26.5865 1.25067 28.2281C1.27394 30.8053 1.6011 33.3709 2.22543 35.8717C3.81209 42.6956 7.21634 48.8142 10.5094 54.7349L11.3244 56.2037C19.8676 71.6315 29.1121 83.9401 39.5939 93.8326C41.5343 95.6627 43.3713 97.688 45.15 99.6467C47.5215 102.381 50.0777 104.949 52.8007 107.334C60.7773 113.997 69.5324 120.765 79.564 128.026C87.822 134.003 95.0878 138.328 102.422 141.639C107.784 144.136 113.621 145.455 119.538 145.506C122.072 145.506 124.6 145.248 127.082 144.738L127.474 144.658C131.243 143.889 135.141 143.093 138.421 140.469C140.049 139.166 141.826 137.969 143.544 136.811C144.445 136.204 145.346 135.596 146.232 134.971C147.026 134.412 147.838 133.873 148.651 133.333C150.656 132.077 152.557 130.663 154.335 129.101C159.255 124.538 158.224 121.379 154.78 117.462C151.016 113.18 147.342 108.682 143.784 104.334C142.369 102.602 140.95 100.873 139.529 99.1467C138.411 97.794 137.3 96.436 136.195 95.0716C134.061 92.4482 131.855 89.7355 129.604 87.1308C125.325 82.1803 123.513 82.0214 118.202 86.1307C114.531 88.9732 110.828 91.8926 107.242 94.7183C104.984 96.498 102.724 98.2752 100.461 100.05C99.7805 100.583 99.0671 101.079 98.3769 101.558L97.9448 101.858C96.5619 100.415 95.1816 98.9723 93.8051 97.5297C79.769 82.858 65.2676 67.694 49.4133 54.1697C49.5756 53.9759 49.7321 53.7897 49.8816 53.6107C50.4327 52.9499 50.9055 52.3865 51.3583 51.8096ZM42.1844 56.1248C52.0161 66.6714 61.8423 77.2247 71.663 87.7839L85.5342 102.689C86.1163 103.316 86.7095 103.934 87.302 104.551C88.2961 105.585 89.3239 106.661 90.2819 107.752C93.3685 111.269 96.9261 111.711 102.18 109.228C103.837 108.359 105.385 107.296 106.791 106.062C107.266 105.677 107.74 105.294 108.22 104.925C111.883 102.117 115.529 99.2901 119.249 96.4095L123.324 93.2518L148.231 123.62C146.954 124.509 145.675 125.432 144.432 126.329C140.989 128.92 137.392 131.299 133.661 133.455C130.704 135.081 126.971 135.6 123.401 135.994C115.833 136.829 108.95 135.542 102.931 132.178L101.767 131.525C95.8032 128.192 89.6364 124.746 83.9792 120.802C76.1694 115.438 68.6566 109.655 61.4734 103.479C57.9785 100.326 54.6446 97 51.4844 93.5121C49.2328 91.1096 46.9062 88.6257 44.4987 86.3C38.2983 80.3147 32.4496 73.0786 26.0939 63.5256C20.4529 55.0504 16.1328 46.1665 12.6496 38.5952C11.3256 35.7159 10.0326 32.2924 10.4757 28.727C10.5641 27.3427 11.0416 26.0118 11.8535 24.8863C15.704 20.5205 19.7388 16.1795 23.6405 11.9823C24.7517 10.7876 25.8621 9.59179 26.9716 8.39453C35.7601 18.3219 45.3526 27.6524 54.4489 36.2755C51.5445 40.2561 48.1576 43.8619 44.3655 47.0105C44.1281 47.2043 43.8835 47.3885 43.639 47.5739C43.1594 47.9247 42.6993 48.3016 42.2607 48.7025C39.6922 51.1334 39.6689 53.4245 42.1844 56.1223V56.1248Z" fill="#000000"></path> <path d="M129.019 13.725C115.969 5.18984 100.415 0.898082 80.0717 0.222997C72.3499 -0.0838615 60.0848 2.40666 53.1463 4.87445C51.946 5.29977 50.8145 5.8983 49.788 6.65101C48.319 7.74019 47.8941 9.24748 48.6521 10.6823C49.5027 12.2915 50.9341 11.8692 51.7892 11.6179C51.9554 11.5688 52.1217 11.5198 52.2853 11.481C61.8648 9.24645 69.2717 8.25093 76.2859 8.25093H76.3848C84.0847 8.29661 91.7554 9.20381 99.2527 10.9561C117.063 14.9886 130.972 23.5355 141.775 37.0857C151.51 49.2955 155.104 63.1467 152.763 79.4303C152.202 83.4136 151.12 87.3059 149.542 91.0076C148.469 93.527 148.338 95.635 149.13 97.6331C149.3 98.1887 149.591 98.701 149.981 99.1325C150.37 99.5641 150.851 99.9045 151.387 100.131C151.704 100.241 152.039 100.298 152.375 100.297C153.136 100.272 153.877 100.049 154.525 99.6513C156.353 98.6099 157.66 96.9664 158.638 94.4773C164.546 79.4497 164.855 64.6061 159.556 50.3594C154.122 35.7478 143.848 23.4237 129.019 13.725Z" fill="#000000"></path> <path d="M126.261 74.7181C126.927 75.6225 127.952 76.7421 129.487 76.7421C129.753 76.7414 130.018 76.7098 130.276 76.6484C132.231 76.1897 132.586 74.2717 132.757 73.3498C133.557 68.9543 132.998 64.4201 131.154 60.3502C129.678 56.9773 128.249 54.039 126.783 51.3671C122.539 43.6291 118.055 38.2743 112.675 34.5158C101.628 26.7978 92.2354 23.0949 82.2212 22.5077C77.4347 22.2279 73.6256 22.8357 70.2375 24.4223C68.0499 25.4476 68.1075 26.9833 68.3365 27.8077C68.8242 29.5635 70.471 29.4956 71.4548 29.4524C72.1812 29.422 72.9542 29.3575 73.8177 29.2587C75.1223 29.1062 76.4257 28.9426 77.7297 28.7786L79.3513 28.5767C84.5065 28.6335 89.8072 29.9329 96.0277 32.6604C107.103 37.5178 114.758 44.3441 119.429 53.5272C120.198 55.0363 120.912 56.6118 121.604 58.1358C122.085 59.1953 122.566 60.2555 123.068 61.3046C124.359 63.7527 124.947 66.5085 124.767 69.2696C124.566 71.2083 125.099 73.1522 126.261 74.7181Z" fill="#000000"></path> </g> <defs> <clipPath id="clip0"> <rect width="163" height="146" fill="white" transform="translate(0.777344)"></rect> </clipPath> </defs> </g>
              </svg>
            </a>
          </nav>
        </header>

        <main class="main">
          <svg xmlns="http://www.w3.org/2000/svg" width="5120" height="456" fill="none" viewBox="0 0 5120 456" preserveAspectRatio="none" class="edge-decorator">
            <path fill="var(--color-background)" d="M2641.4 401.5C2613.31 399.999 2525.75 198 2121.01 198C1862 198 1840 264.5 1806.88 259.5C1773.77 254.499 1723.34 129.991 1562.17 136C1401 142.009 1366.58 313.5 1339 321C1311.42 328.5 1279 226.5 1034.79 234.5C802.99 242.093 724.297 318.5 697 313C669.703 307.5 681 75.9996 430.496 32.4996C214.304 -5.042 99.7464 183.937 60.6394 266.475C51.4353 285.9 27.9703 295.392 8.5729 286.129C-15.3473 274.705 -43 292.144 -43 318.652V429.5C-43 443.859 -31.3592 455.5 -16.9999 455.5H5103C5127.3 455.5 5147 435.8 5147 411.5V232.89C5147 226.643 5146.46 220.404 5144.55 214.457C5136.92 190.729 5108.7 128.5 5022.5 128.5C4881 128.5 4935 253.704 4838.83 249C4808.16 247.499 4757.27 55.5004 4535 59C4312.73 62.4996 4283.98 270.5 4250.5 268.5C4217.02 266.5 4197 199 4037.27 189.5C3834.76 177.455 3790.86 285 3753.5 279C3716.14 273 3652.96 98.8238 3377.5 153.5C3156.46 197.374 3191.5 387.48 3139.82 376.5C3118.64 371.999 3078.5 339 2948.03 339C2894.2 339 2890.37 330.676 2837.19 339C2708.5 359.141 2669.5 403 2641.4 401.5Z">
            </path>
          </svg>

          <section id="home" class="home-section active">
            <div class="home-content">
              <h2 class="trademark-name">OL√Å</h2>
              <p>Experimente os melhores <strong class="trademark-name" style="color: var(--primary-dark) !important;">biscoitos amanteigados caseiros</strong> feitos com receitas pr√≥prias e ingredientes premium.</p>
              <button class="cta-button">Ver nosso card√°pio</button>
            </div>
            <div class="home-image" id="homeImageContainer">
              <canvas id="homePhysicsCanvas"></canvas>
            </div>
          </section>

          <section id="menu" class="menu-section">
            <h2 class="trademark-name">CARD√ÅPIO</h2>
            <div class="menu-grid" id="menuGrid">
              <!-- Menu items will be loaded here -->
            </div>
          </section>

          <section id="about" class="about-section">
            <h2 class="trademark-name">HIST√ìRIA</h2>
            <div class="about-content" id="aboutContent">
              <div class="typewriter-text" id="typewriterText"></div>
            </div>
          </section>

          <section id="gallery" class="gallery-section">
            <h2 class="trademark-name">GALERIA</h2>
            <p class="gallery-subtitle">Veja alguns de nossos clientes satisfeitos e os bastidores dos biscoidinos!</p>
            ${this.renderGalleryCarousel()}
          </section>

          <section id="contact" class="contact-section">
            <h2 class="trademark-name">CONTATOS</h2>
            <div class="contact-info">
              <a href="https://wa.me/5511953826504?text=Ol√°,%20gostaria%20de%20encomendar%20biscoitos!" target="_blank" class="contact-link">
                <svg width="140px" height="140px" viewBox="0 0 400 400" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M84.7925 257.334C1.81069 106.044 237.525 -11.6463 321.16 119.453C396.366 237.339 251.357 391.573 150.736 312.145" stroke="#219143" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M89.5909 265.912C34.5405 357.344 49.8143 347.445 133.267 311.303" stroke="#219143" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M170.381 113.42C60.1005 141.74 240.793 341.184 288.582 236.047" stroke="#219143" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M177.338 175.365C186.032 197.073 208.905 214.528 227.906 227.195" stroke="#219143" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M177.338 126.062C187.693 143.231 203.319 159.586 178.602 168.412" stroke="#219143" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M285.431 228.46C262.184 210.573 250.584 200.134 232.965 225.301" stroke="#219143" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"></path> </g>
                </svg>
                <span>(11) 95382-6504</span>
              </a>
              <a href="https://www.instagram.com/biscoidino/" target="_blank" class="contact-link">
                <svg viewBox="0 0 400 400" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M97.7584 266.912C92.6853 250.358 95.0759 232.919 92.9403 215.984C91.1224 201.584 87.7749 124.026 99.362 112.544C120.027 92.065 273.627 80.7436 295.286 109.362C311.015 130.141 308.133 170.886 308.133 195.297C308.133 221.663 314.304 262.39 293.679 282.825C262.646 313.578 150.802 310.685 108.998 300.331" stroke="#c32280" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M92.3525 178.22C108.076 172.753 152.923 181.568 154.665 177.898C159.057 168.643 170.325 149.34 197.916 144.039C217.288 140.317 246.133 144.039 255.421 162.999C301.023 256.088 204.618 283.492 177.089 268.705C152.735 255.624 154.665 237.915 154.665 224.07" stroke="#c32280" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M190.42 185.487C195.609 179.783 206.27 172.158 214.548 174.227C240.637 180.749 240.2 231.513 212.938 236.968C187.338 242.087 168.04 204.722 190.42 193.53" stroke="#c32280" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M271.379 177.772C278.12 176.84 299.834 177.637 306.406 176.475" stroke="#c32280" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M279.81 139.067C279.81 138.491 279.81 137.919 279.81 137.343" stroke="#c32280" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"></path> </g>
                </svg>
                <span>@biscoidino</span>
              </a>
            </div>
          </section>

          <svg xmlns="http://www.w3.org/2000/svg" width="5120" height="456" fill="none" viewBox="0 0 5120 456" preserveAspectRatio="none" class="edge-decorator bottom">
            <path fill="var(--color-background)" d="M2641.4 401.5C2613.31 399.999 2525.75 198 2121.01 198C1862 198 1840 264.5 1806.88 259.5C1773.77 254.499 1723.34 129.991 1562.17 136C1401 142.009 1366.58 313.5 1339 321C1311.42 328.5 1279 226.5 1034.79 234.5C802.99 242.093 724.297 318.5 697 313C669.703 307.5 681 75.9996 430.496 32.4996C214.304 -5.042 99.7464 183.937 60.6394 266.475C51.4353 285.9 27.9703 295.392 8.5729 286.129C-15.3473 274.705 -43 292.144 -43 318.652V429.5C-43 443.859 -31.3592 455.5 -16.9999 455.5H5103C5127.3 455.5 5147 435.8 5147 411.5V232.89C5147 226.643 5146.46 220.404 5144.55 214.457C5136.92 190.729 5108.7 128.5 5022.5 128.5C4881 128.5 4935 253.704 4838.83 249C4808.16 247.499 4757.27 55.5004 4535 59C4312.73 62.4996 4283.98 270.5 4250.5 268.5C4217.02 266.5 4197 199 4037.27 189.5C3834.76 177.455 3790.86 285 3753.5 279C3716.14 273 3652.96 98.8238 3377.5 153.5C3156.46 197.374 3191.5 387.48 3139.82 376.5C3118.64 371.999 3078.5 339 2948.03 339C2894.2 339 2890.37 330.676 2837.19 339C2708.5 359.141 2669.5 403 2641.4 401.5Z">
            </path>
          </svg>          
        </main>

        <footer class="footer">
          <p>¬© 2025 BISCOIDINO‚Ñ¢</p>
          <br>
          <p>Feito com <img src="/biscuits/heart_baunilha1.png" alt="amor" class="footer-icon"> por amantes de biscoitos para amantes de biscoitos.</p>
        </footer>
      </div>
    `;

    this.loadMenu();
    this.setupNavigation();
    
    setTimeout(() => {
      initHomePhysics();
    }, 100);

    // Initialize gallery carousel after DOM is ready (backup initialization)
    setTimeout(() => {
      console.log('üöÄ Initial gallery setup...');
      if (document.querySelector('.gallery-slide')) {
        updateGallerySlide(); // Ensure initial state is correct
      }
    }, 200);
  }

  private loadMenu(): void {
    const menuItems = [
      {
        name: "Biscoitos de Baunilha",
        description: "Deliciosos biscoitos artesanais com sabor suave de baunilha (150g)",
        price: "R$ 15,00",
        image: "/products/baunilha_package.png",
        images: [
          "/products/baunilha_package.png",
          "/biscuits/biscoidino_biscuit1.png",
          "/biscuits/flower_baunilha1.png", 
          "/biscuits/heart_baunilha1.png",
          "/biscuits/star_baunilha1.png",
          "/biscuits/flower_baunilha2.png",
          "/biscuits/heart_baunilha2.png",
          "/products/baunilha_biscuits.png"
        ]
      },
      {
        name: "Biscoitos de Parmes√£o",
        description: "Biscoitos salgados crocantes com queijo parmes√£o premium (150g)",
        price: "R$ 15,00",
        image: "/products/parmesao_biscuit_package1.png",
        images: [
          "/products/parmesao_biscuit_package1.png",
          "/products/parmesao_biscuit_package2.png",
          "/products/parmesao_biscuits.png"
        ]
      }
    ];

    // Armazenar os dados dos produtos globalmente para uso nos modais
    (window as any).menuItemsData = menuItems;

    const menuGrid = document.getElementById('menuGrid');
    if (menuGrid) {
      menuGrid.innerHTML = menuItems.map((item, index) => `
        <div class="menu-item">
          <div class="product-image-container">
            <img src="${item.image}" alt="${item.name}" class="menu-item-image">
            <div class="image-actions">
              <button class="action-button detail-button" onclick="openProductModal(${index})" title="Ver detalhes">
                üîç
              </button>
              <button class="action-button physics-button" onclick="openPhysicsView('${item.name.toLowerCase().includes('parmes√£o') ? 'parmesao' : 'baunilha'}')" title="Ver dentro do pacote">
                üì¶
              </button>
            </div>
          </div>
          <h3>${item.name}</h3>
          <p>${item.description}</p>
          <div class="price">${item.price}</div>
        </div>
      `).join('');
    }
  }

  private setupNavigation(): void {
    const navLinks = document.querySelectorAll('.nav-link');
    const sections = document.querySelectorAll('section');

    navLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const currentLink = e.currentTarget as HTMLAnchorElement;
        const targetId = currentLink.getAttribute('href')?.substring(1);
        
        // Update active nav link
        navLinks.forEach(nav => nav.classList.remove('active'));
        currentLink.classList.add('active');
        
        // Show/hide sections
        sections.forEach(section => {
          if (section.id === targetId) {
            section.classList.add('active');
            
            // Initialize gallery when gallery section becomes active
            if (targetId === 'gallery') {
              setTimeout(() => {
                console.log('üé≠ Gallery section activated, initializing carousel...');
                initializeGalleryCarousel();
              }, 50);
            }
            
            // When about section becomes active, scroll to top and reset typewriter
            if (targetId === 'about') {
              // Smooth scroll to top of page first
              window.scrollTo({
                top: 0,
                behavior: 'smooth'
              });
              
              // Reset and restart typewriter after scrolling completes
              setTimeout(() => {
                console.log('üìù About section activated, resetting typewriter...');
                this.resetAndRestartTypewriter();
              }, 50); // Wait for smooth scroll to complete
            }
            else {
              this.destroyTypewriterEffect();
            }
          } else {
            section.classList.remove('active');
          }
        });
      });
    });

    // CTA button functionality
    const ctaButton = document.querySelector('.cta-button');
    if (ctaButton) {
      ctaButton.addEventListener('click', () => {
        const menuLink = document.querySelector('a[href="#menu"]') as HTMLAnchorElement;
        menuLink?.click();
      });
    }
  }

  private resetAndRestartTypewriter(): void {
    console.log('üîÑ Resetting typewriter effect...');
    
    // Get elements
    const typewriterText = document.getElementById('typewriterText');
    const aboutContent = document.getElementById('aboutContent');
    
    if (!typewriterText || !aboutContent) {
      console.error('‚ùå Required elements not found for typewriter reset');
      return;
    }
    
    // Force stop any running typewriter
    this.typewriterRunning = false;
    
    // Clear ALL tracked event listeners
    this.activeEventListeners.forEach(({ element, event, handler }) => {
      try {
        element.removeEventListener(event, handler);
        console.log(`üßπ Removed ${event} listener`);
      } catch (e) {
        console.warn(`‚ö†Ô∏è Could not remove ${event} listener:`, e);
      }
    });
    this.activeEventListeners = [];
    
    // Clear all timeouts that might be running
    for (let i = 1; i < 99999; i++) {
      window.clearTimeout(i);
    }
    
    // Clear all content
    typewriterText.innerHTML = '';
    
    // Remove all scroll images from anywhere in the document
    const scrollImages = document.querySelectorAll('.scroll-image');
    scrollImages.forEach(img => img.remove());
    
    // Remove ALL scroll hints from anywhere in the document
    const scrollHints = document.querySelectorAll('.scroll-hint-floating, .scroll-hint');
    scrollHints.forEach(hint => {
      console.log('üßπ Removing scroll hint:', hint);
      hint.remove();
    });
    
    // Also remove any orphaned elements that might be in body
    const orphanedHints = document.body.querySelectorAll('[class*="scroll-hint"]');
    orphanedHints.forEach(hint => {
      console.log('üßπ Removing orphaned hint:', hint);
      hint.remove();
    });
    
    // Use a delay to ensure all cleanup is complete
    setTimeout(() => {
      this.initTypewriterEffect();
    }, 300);
    
    console.log('‚úÖ Typewriter effect reset and restarted');
  }

  //destroyTypewriterEffect code below
  private destroyTypewriterEffect(): void {
    console.log('üß® Destroying typewriter effect...');

    const existingHint = document.querySelector('.scroll-hint-floating');
    if (existingHint) existingHint.remove();
    
    // Force stop any running typewriter
    this.typewriterRunning = false;
    // Clear ALL tracked event listeners
    this.activeEventListeners.forEach(({ element, event, handler }) => {
      try {
        element.removeEventListener(event, handler);
      } catch (e) {
        console.warn(`‚ö†Ô∏è Could not remove ${event} listener:`, e);
      }
    });
    this.activeEventListeners = [];
  }

  private initTypewriterEffect(): void {
    // Prevent multiple instances running simultaneously
    if (this.typewriterRunning) {
      console.log('üö´ Typewriter already running, skipping initialization');
      return;
    }
    
    const typewriterText = document.getElementById('typewriterText');
    const aboutContent = document.getElementById('aboutContent');
    
    if (!typewriterText || !aboutContent) return;
    
    this.typewriterRunning = true;
    const self = this; // Store reference for inner functions
    
    // Helper function to track event listeners
    const addTrackedListener = (element: any, event: string, handler: any, options?: any) => {
      element.addEventListener(event, handler, options);
      self.activeEventListeners.push({ element, event, handler, options });
    };
    
    // Story content with images
    const storyData = [
      { 
        text: "A Biscoidino nasceu de uma inesperada oportunidade de se reinventar.",
        image: null
      },
      { 
        text: "Quando Micaela, que trabalhava com finan√ßas h√° mais de 15 anos, viu sua rotina mudar radicalmente com o diagn√≥stico de TEA de seu filho Lucas.",
        image: "/about/mae_filho.png"
      },
      { 
        text: "Imediatamente deixou seu emprego e passou a se dedicar em tempo integral ao tratamento e cuidados dele.",
        image: "/about/tea.png"
      },
      // { 
      //   text: "Um dos nossos desafios era a seletividade alimentar.",
      //   image: "/about/fornada.png"
      // },
      { 
        text: "Lucas ama dinossauros, disso surgiu a ideia de assar biscoitos nesse formato para se tornarem mais atrativos para ele.",
        image: "/biscuits/biscoidino_biscuit1.png"
      },
      { 
        text: "Sem nenhuma expectativa, levamos pra algumas pessoas experimentarem e rapidamente a receita se tornou um sucesso. üíö",
        image: "/about/estoque.png"
      }
    ];
    
    // Clear any existing content
    typewriterText.innerHTML = '';
    
    // State management
    let currentParagraph = 0;
    let currentChar = 0;
    let currentScrollImage: HTMLImageElement | null = null;
    let imageProgress = 0; // 0 to 1 (0 = right side, 1 = center)
    let lastScrollY = window.scrollY; // Lock to current position
    console.log('üîí Initial scroll position locked at:', lastScrollY);
    
    // Control flags for progression
    let paragraphCompleted = false;
    let imageAtCenter = false;
    let typingStarted = false; // Flag to track if we've started typing the current paragraph
    let imageLocked = false; // Flag to prevent further image movement after reaching center
    
    const typeSpeed = 55;
    const pauseBetweenParagraphs = 1000;
    
    function createScrollImage(imageSrc: string, paragraphIndex: number): HTMLImageElement {
      console.log('üé® Creating scroll image:', imageSrc, 'for paragraph:', paragraphIndex);
      
      // Remove any existing image for this paragraph to prevent duplicates
      const existingImages = aboutContent?.querySelectorAll('.scroll-image');
      existingImages?.forEach(img => {
        const imgElement = img as HTMLImageElement;
        if (imgElement.src.includes(imageSrc.split('/').pop() || '')) {
          console.log('üóëÔ∏è Removing duplicate image');
          imgElement.remove();
        }
      });
      
      const img = document.createElement('img');
      img.src = imageSrc;
      img.className = 'scroll-image';
      img.style.opacity = '0.9';
      img.dataset.paragraph = paragraphIndex.toString(); // Track which paragraph this image belongs to
      
      // Calculate vertical position based on paragraph index (starting from second paragraph)
      const baseTopOffset = 70; // Start position in pixels from top of about-section (adjusted for larger images)
      const verticalSpacing = isMobileDevice() ? 400 : 500; // Space between each image (increased for larger image sizes)
      const topPosition = baseTopOffset + (paragraphIndex - 1) * verticalSpacing;
      
      // img.style.top = `${topPosition}px`;
      
      // Add to about-content container for relative positioning
      if (typewriterText) {
        typewriterText.appendChild(img);
        console.log('‚úÖ Image created and added to about-content at position:', topPosition);
      }
      
      return img;
    }
    
    function showScrollHint() {
      // Remove existing hint first
      const existingHint = document.querySelector('.scroll-hint-floating');
      if (existingHint) existingHint.remove();
      
      if (!currentScrollImage) {
        console.log('‚ùå No current image to show hint for');
        return;
      }
      
      // Get image position relative to its parent (aboutContent)
      const aboutContentRect = aboutContent!.getBoundingClientRect();
      const imageRect = currentScrollImage.getBoundingClientRect();
      const imageRelativeTop = imageRect.bottom - aboutContentRect.top;
      
      // Create floating hint at same height as image
      const scrollHint = document.createElement('div');
      scrollHint.className = 'scroll-hint-floating';
      // <span style="white-space: nowrap;color: var(--primary-dark); font-style: italic; font-size: 1rem;">Role para baixo para continuar a hist√≥ria...</span>
      scrollHint.innerHTML = `
        
        <div class="scroll-ball">
          <svg viewBox="0 -15.5 91 91" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M45.4294 49.6574C49.7395 44.2098 53.604 39.3621 57.4357 34.4856C63.7103 26.4986 69.8405 18.3922 76.2864 10.5477C78.9741 7.27712 82.2998 4.52502 85.3833 1.58791C86.7071 0.326427 88.4109 -0.774937 90.0065 0.720856C91.7786 2.38073 90.6629 4.19232 89.2846 5.57785C74.4514 20.4826 64.2741 38.9336 51.3705 55.3092C47.5677 60.1346 44.3654 60.7634 39.6608 56.6777C38.1526 55.4129 36.7389 54.0397 35.4308 52.569C26.2532 41.8805 16.9876 31.2622 8.06665 20.3624C5.20239 16.8628 3.23017 12.6177 1.00124 8.62848C0.621879 7.94851 0.775416 6.15672 1.08521 6.0504C2.22264 5.65659 3.88641 5.22532 4.71077 5.7727C7.95308 7.92746 11.3608 10.0744 13.9593 12.9097C20.2312 19.7534 26.0667 26.9954 32.111 34.0484C35.6657 38.1971 39.2913 42.2848 42.8663 46.4165C43.6467 47.3202 44.3523 48.2929 45.4294 49.6574Z" fill="#ffffff"></path> </g></svg>    
        </div>
      `;
      
      scrollHint.style.pointerEvents = 'none';
      scrollHint.style.opacity = '0';
      scrollHint.style.transition = 'opacity 0.4s ease-in-out';
      
      if (typewriterText) typewriterText.appendChild(scrollHint);
      
      // Fade in after a brief moment
      setTimeout(() => {
        scrollHint.style.opacity = '1';
      }, 50);
      
      console.log('üìù Scroll hint shown at image position:', imageRelativeTop + 20);
    }
    
    function hideScrollHint() {
      const scrollHint = document.querySelector('.scroll-hint-floating') as HTMLElement;
      if (scrollHint) {
        // Fade out smoothly
        scrollHint.style.opacity = '0';
        
        // Remove after fade completes
        setTimeout(() => {
          if (scrollHint.parentNode) {
            scrollHint.remove();
          }
        }, 400); // Match the transition duration
        
        console.log('üìù Scroll hint fading out');
      }
    }
    
    let scrollTimeout: number | null = null;
    
    // Function to detect if device is mobile
    function isMobileDevice(): boolean {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
             || window.innerWidth <= 768;
    }
    
    // Function to get the appropriate center position based on device
    function getCenterPosition(): number {
      return isMobileDevice() ? 0 : 0;
    }
    
    function updateImagePosition(progress: number) {
      if (!currentScrollImage) return;
      
      // Move from right (120%) to center (mobile: 30%, desktop: 40%) based on progress
      const startPosition = 120;
      const centerPosition = getCenterPosition();
      const currentPosition = startPosition - (progress * (startPosition - centerPosition));
      
      currentScrollImage.style.right = `${currentPosition}%`;
      
      console.log('üñºÔ∏è Image position:', { progress, currentPosition, centerPosition, isMobile: isMobileDevice(), isAtCenter: progress >= 1 });
    }

    // Handle wheel events for more precise control when image is active
    function handleWheel(e: WheelEvent) {
      // Prevent default scroll behavior when we have an active image
      e.preventDefault();
      e.stopPropagation();

      // ALWAYS hide scroll hint when user wheels (regardless of image state)
      hideScrollHint();
      
      // Clear any existing timeout and set a new one to show hint again if user stops
      if (scrollTimeout) clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        if (currentScrollImage && !imageLocked) {
          showScrollHint();
        }
      }, 500); // Show hint again after 0.5 seconds of no wheel activity
      

      if (currentScrollImage && !imageLocked) {  
        // Use wheel delta for image movement
        const wheelSensitivity = 0.001;
        const progressChange = e.deltaY * wheelSensitivity;
        
        const oldProgress = imageProgress;
        imageProgress = Math.max(0, Math.min(1, imageProgress + progressChange));
        
        console.log('üé° WHEEL controlling image:', { wheelDelta: e.deltaY, progressChange, oldProgress, newProgress: imageProgress });
        
        updateImagePosition(imageProgress);
        
        // Update imageAtCenter flag
        const wasAtCenter = imageAtCenter;
        imageAtCenter = imageProgress >= 1;
        
        // If image just reached center for the first time AND we haven't started typing yet
        if (imageAtCenter && !wasAtCenter && !typingStarted) {
          typingStarted = true;
          imageLocked = true; // Lock the image at center position - no more movement
          // Force image to exact center position when locking
          if (currentScrollImage) {
            currentScrollImage.style.right = `${getCenterPosition()}%`;
          }
          console.log('üîí Image reached center and locked - starting to type paragraph');
          setTimeout(() => typeNextChar(), pauseBetweenParagraphs);
        }
        
        // Check if both conditions are met for progression (only if we've already started typing)
        if (typingStarted) {
          checkForProgression();
        }
        
        return false;
      }
    }

    // Touch handling for mobile devices
    let touchStartY = 0;
    let touchLastY = 0;
    
    function handleTouchStart(e: TouchEvent) {
      if (currentScrollImage && !imageLocked) {
        touchStartY = e.touches[0].clientY;
        touchLastY = touchStartY;
        console.log('üëÜ TOUCH START:', { touchStartY });
      }
    }
    
    function handleTouchMove(e: TouchEvent) {
      // Prevent default scroll behavior when we have an active image
      e.preventDefault();
      e.stopPropagation();
  
      // ALWAYS hide scroll hint when user starts touching (regardless of image state)
      hideScrollHint();
      
      // Clear any existing timeout and set a new one to show hint again if user stops
      if (scrollTimeout) clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        if (currentScrollImage && !imageLocked) {
          showScrollHint();
        }
      }, 500); // Show hint again after 0.5 seconds of no touching
      
      if (currentScrollImage && !imageLocked) {
        const touchCurrentY = e.touches[0].clientY;
        const touchDelta = touchLastY - touchCurrentY; // Inverted for natural scroll direction
        
        // Use touch delta for image movement (similar to wheel)
        const touchSensitivity = 0.003;
        const progressChange = touchDelta * touchSensitivity;
        
        const oldProgress = imageProgress;
        imageProgress = Math.max(0, Math.min(1, imageProgress + progressChange));
        
        console.log('üëÜ TOUCH controlling image:', { touchDelta, progressChange, oldProgress, newProgress: imageProgress });
        
        updateImagePosition(imageProgress);
        
        // Update imageAtCenter flag
        const wasAtCenter = imageAtCenter;
        imageAtCenter = imageProgress >= 1;
        
        // If image just reached center for the first time AND we haven't started typing yet
        if (imageAtCenter && !wasAtCenter && !typingStarted) {
          // Remove scroll hint when image reaches center
          const scrollHint = document.querySelector('.scroll-hint');
          if (scrollHint) {
            scrollHint.remove();
            console.log('üìù Scroll hint removed - image reached center');
          }
          
          typingStarted = true;
          imageLocked = true; // Lock the image at center position - no more movement
          // Force image to exact center position when locking
          if (currentScrollImage) {
            currentScrollImage.style.right = `${getCenterPosition()}%`;
          }
          console.log('üîí Image reached center and locked - starting to type paragraph');
          setTimeout(() => typeNextChar(), pauseBetweenParagraphs);
        }
        
        // Check if both conditions are met for progression (only if we've already started typing)
        if (typingStarted) {
          checkForProgression();
        }
        
        touchLastY = touchCurrentY;
        return false;
      }
    }
    
    function handleTouchEnd(_e: TouchEvent) {
      if (currentScrollImage && !imageLocked) {
        console.log('üëÜ TOUCH END');
        // Reset touch tracking
        touchStartY = 0;
        touchLastY = 0;
      }
    }
    
    function checkForProgression() {
      // Only advance if BOTH conditions are true: paragraph completed AND image at center
      if (paragraphCompleted && (currentParagraph == 0 || imageAtCenter) && currentParagraph < storyData.length - 1) {
        console.log('üéØ Both conditions met - advancing to next paragraph');
        console.log('   üìù Paragraph completed:', paragraphCompleted);
        console.log('   üñºÔ∏è Image at center:', imageAtCenter);
        
        // Remove scroll hint if it exists
        const scrollHint = document.querySelector('.scroll-hint');
        if (scrollHint) {
          scrollHint.remove();
          console.log('üìù Scroll hint removed - advancing to next paragraph');
        }
        
        // Lock current image at center
        if (currentScrollImage) {
          currentScrollImage.style.right = `${getCenterPosition()}%`;
          console.log('üîí Image locked at center position');
        }
        
        // Reset flags
        paragraphCompleted = false;
        imageAtCenter = false;
        typingStarted = false; // Reset typing flag for the new paragraph
        imageLocked = false; // Unlock for the new image
        
        // Advance to next paragraph
        currentParagraph++;
        currentChar = 0;
        currentScrollImage = null;
        imageProgress = 0;
        
        // Create image for the NEW current paragraph (if it has one)
        const currentStoryItem = storyData[currentParagraph];
        if (currentStoryItem && currentStoryItem.image) {
          currentScrollImage = createScrollImage(currentStoryItem.image, currentParagraph);
          imageProgress = 0;
          updateImagePosition(0);
          console.log('üñºÔ∏è Created image for current paragraph:', currentStoryItem.text.substring(0, 30) + '...');
 
          // Scroll to position where image is visible (with some offset for better view)
          const aboutContentRect = aboutContent!.getBoundingClientRect();
          const imageRect = currentScrollImage.getBoundingClientRect();
          const imageRelativeTop = imageRect.bottom - aboutContentRect.top;
          const targetScrollY = imageRelativeTop - 300;
          
          // Smooth scroll with longer duration for better UX
          window.scrollTo({
            top: currentParagraph <= 1 ? 0 : targetScrollY,
            behavior: 'smooth'
          });
          
          // Update locked scroll position
          lastScrollY = targetScrollY;

          setTimeout(() => {
            showScrollHint();
          }, 800); // Show hint after scroll completes
        } else {
          // No image for this paragraph, start typing immediately
          setTimeout(() => typeNextChar(), pauseBetweenParagraphs);
        }
      } else {
        console.log('‚è≥ Waiting for conditions:', { 
          paragraphCompleted, 
          imageAtCenter, 
          canProgress: currentParagraph < storyData.length - 1 
        });
      }
    }
    
    function typeNextChar() {
      if (currentParagraph >= storyData.length) {
        // Finished typing, cleanup
        setTimeout(() => {
          const cursor = document.querySelector('.typewriter-cursor');
          if (cursor) cursor.remove();

          // DON'T remove the last image - let it stay visible
          // Keep the last image locked at center position
          if (currentScrollImage) {
            currentScrollImage.style.right = `${getCenterPosition()}%`;
            console.log('üîí Last image locked at center - keeping visible');
            currentScrollImage = null; // Clear reference but don't remove from DOM
          }
          
          // Mark typewriter as no longer running
          self.typewriterRunning = false;
          console.log('‚úÖ Typewriter finished and flag cleared');

          // Remove scroll event listeners
          window.removeEventListener('wheel', handleWheel);
          window.removeEventListener('touchstart', handleTouchStart);
          window.removeEventListener('touchmove', handleTouchMove);
          window.removeEventListener('touchend', handleTouchEnd);
          console.log('üßπ Removed scroll and touch event listeners after completion');
        }, 2000);
        return;
      }
      
      const currentStoryItem = storyData[currentParagraph];
      const currentText = currentStoryItem.text;
      
      if (currentChar === 0) {
        // Start new paragraph
        const p = document.createElement('p');
        
        // Calculate position based on paragraph index and corresponding image
        if (currentParagraph > 0) {
          // For paragraphs with images, position them below the actual image
          const positionParagraph = () => {
            let paragraphTopPosition = 0;
            
            if (currentScrollImage) {
              // Get the image's top position (from its style.top)
              const imageTop = parseInt(currentScrollImage.style.top) || 0;
              
              if (currentScrollImage.complete && currentScrollImage.naturalHeight > 0) {
                // Image is loaded, use actual height
                const imageHeight = currentScrollImage.offsetHeight;
                paragraphTopPosition = imageTop + imageHeight + 20; // 20px below the image
                
                console.log('üìç Positioning paragraph below loaded image:', {
                  imageTop,
                  imageHeight,
                  paragraphTop: paragraphTopPosition
                });
              } else {
                // Image not loaded yet, estimate height
                const estimatedImageHeight = 150; // Reasonable estimate
                paragraphTopPosition = imageTop + estimatedImageHeight + 20; // 20px below estimated image
                
                console.log('üìç Using estimated paragraph position:', {
                  imageTop,
                  estimatedHeight: estimatedImageHeight,
                  paragraphTop: paragraphTopPosition
                });
              }
            } else {
              // Fallback - no current image
              const baseTopOffset = 80;
              const verticalSpacing = isMobileDevice() ? 400 : 500;
              const imageTopPosition = baseTopOffset + (currentParagraph - 1) * verticalSpacing;
              paragraphTopPosition = imageTopPosition + 170; // Estimated image + spacing
              
              console.log('üìç Using fallback paragraph position:', paragraphTopPosition);
            }
            
            // p.style.top = `${paragraphTopPosition}px`;
          };
          
          // p.style.position = 'absolute';
          p.style.left = '50%';
          // p.style.transform = 'translateX(-50%)';
          // p.style.width = '80%';
          
          // Position immediately, and also when image loads (if not loaded yet)
          positionParagraph();
          
          if (currentScrollImage && !currentScrollImage.complete) {
            addTrackedListener(currentScrollImage, 'load', positionParagraph, { once: true });
          }
        }
        
        p.style.margin = '1rem 0';
        p.style.fontSize = '1.2rem';
        p.style.color = 'var(--text-light)';
        p.style.lineHeight = '1.7';
        p.style.textAlign = 'center';
        if (typewriterText) typewriterText.appendChild(p);
      }
      
      if (currentChar < currentText.length) {
        // Remove previous cursor
        const existingCursor = document.querySelector('.typewriter-cursor');
        if (existingCursor) existingCursor.remove();
        
        // Add next character
        const currentP = typewriterText?.lastElementChild as HTMLParagraphElement;
        const textContent = currentText.substring(0, currentChar + 1);
        
        // Create cursor
        const cursor = document.createElement('span');
        cursor.className = 'typewriter-cursor';
        cursor.textContent = '|';
        
        currentP.innerHTML = textContent + cursor.outerHTML;
        
        currentChar++;
        setTimeout(typeNextChar, typeSpeed);
      } else {
        // Finished current paragraph
        const existingCursor = document.querySelector('.typewriter-cursor');
        if (existingCursor) existingCursor.remove();
        
        console.log(`‚úÖ Finished paragraph ${currentParagraph}: "${currentText}"`);
        
        if (currentParagraph < storyData.length - 1) {
          // Middle paragraphs - set flag that paragraph is completed
          paragraphCompleted = true;
          console.log('üìù Paragraph completed, waiting for image to reach center');
          
          // Check if we can advance immediately
          checkForProgression();
        } else {
          // Last paragraph - finish and ensure image is at center
          if (currentScrollImage) {
            currentScrollImage.style.right = `${getCenterPosition()}%`;
            console.log('üîí Final image repositioned to center');
          }
          currentParagraph = storyData.length; // Trigger completion
          setTimeout(typeNextChar, pauseBetweenParagraphs);
        }
      }
    }
    
    currentParagraph = 0; // First paragraph
    currentChar = 0;
    
    // Reset progression flags
    paragraphCompleted = false;
    imageAtCenter = false;
    typingStarted = false; // Reset typing flag - we'll wait for image to reach center
    imageLocked = false; // Unlock for the new image
    
    // Create image for the SECOND paragraph (we're about to type it)
    const currentStoryItem = storyData[currentParagraph];
    if (currentStoryItem.image) {
      currentScrollImage = createScrollImage(currentStoryItem.image, currentParagraph);
      imageProgress = 0;
      updateImagePosition(0);
    }
    
    addTrackedListener(window, 'wheel', handleWheel, { passive: false });
    addTrackedListener(window, 'touchstart', handleTouchStart, { passive: false });
    addTrackedListener(window, 'touchmove', handleTouchMove, { passive: false });
    addTrackedListener(window, 'touchend', handleTouchEnd, { passive: false });
    lastScrollY = window.scrollY;

    // Start typing first paragraph
    setTimeout(typeNextChar, 500);
  }

  private renderGalleryCarousel(): string {
    // Mapear automaticamente as imagens da pasta public/gallery
    const galleryData = [
      {
        image: '/gallery/galeria1.jpeg',
        text: 'Parmes√£o e Baunilha!',
      },
      {
        image: '/gallery/galeria2.jpeg',
        text: 'Produ√ß√£o de biscoitos!',
      },
      {
        image: '/gallery/galeria3.jpeg',
        text: 'Perfeito para a hora do ch√°!',
      },
      {
        image: '/gallery/galeria4.jpeg',
        text: 'Pacotes de baunilha!',
      },
      {
        image: '/gallery/galeria5.jpeg',
        text: 'Biscoitos prontos para festa!',
      },
      {
        image: '/gallery/galeria6.jpeg',
        text: 'Mini biscoidinos para festa!',
      },
      {
        image: '/gallery/galeria7.jpeg',
        text: 'Hmm, parmes√£o, que del√≠cia!',
      },
      {
        image: '/gallery/galeria8.jpeg',
        text: 'Biscoidinos com brinde de Halloween!',
      },
      {
        image: '/gallery/galeria9.jpeg',
        text: 'Biscoidinos assustadores de Halloween! üéÉ',
      }
    ];

    return `
      <div class="gallery-carousel-container">
        <div class="gallery-carousel">
          <div class="gallery-slides-container" id="gallerySlides">
            ${galleryData.map((item, index) => `
              <div class="gallery-slide ${index === 0 ? 'active' : ''}" data-image-src="${item.image}" data-slide-index="${index}">
                <div class="gallery-slide-overlay">
                  <p class="gallery-text">"${item.text}"</p>
                </div>
              </div>
            `).join('')}
          </div>
          <button class="gallery-nav-btn prev" onclick="galleryPrevSlide()">‚Äπ</button>
          <button class="gallery-nav-btn next" onclick="galleryNextSlide()">‚Ä∫</button>
          <div class="gallery-indicators" id="galleryIndicators">
            ${galleryData.map((_, index) => `
              <span class="gallery-indicator ${index === 0 ? 'active' : ''}" onclick="galleryGoToSlide(${index})"></span>
            `).join('')}
          </div>
        </div>
      </div>
    `;
  }
}

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
  const app = new BiscoidinoApp();
  // Make app globally available for PWA install function
  (window as any).BiscoidinoApp = app;
});

// Preload the logo to ensure smooth animation
const preloadLogo = new Image();
preloadLogo.src = '/biscoidino_logo.png';

// Global functions for modals and physics simulation
(window as any).openProductModal = function(productIndex: number) {
  const menuItems = (window as any).menuItemsData;
  const product = menuItems[productIndex];
  
  // Create modal HTML
  const modalHTML = `
    <div id="productModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>${product.name}</h2>
          <button class="close-modal" onclick="closeProductModal()">&times;</button>
        </div>
        <div class="carousel-container">
          <div class="carousel">
            <div class="carousel-images" id="carouselImages" title="Arraste para navegar ou use as setas">
              ${product.images.map((img: string, idx: number) => `
                <div class="carousel-slide ${idx === 0 ? 'active' : ''}">
                  <img src="${img}" alt="${product.name}" class="carousel-image" style="transform: scale(1) translate(0px, 0px);" />
                </div>
              `).join('')}
            </div>
            <button class="carousel-btn prev" onclick="changeCarouselImage(-1)" title="Imagem anterior">‚Äπ</button>
            <button class="carousel-btn next" onclick="changeCarouselImage(1)" title="Pr√≥xima imagem">‚Ä∫</button>
            <div class="zoom-controls">
              <button class="zoom-btn" onclick="zoomImage(-1)" title="Diminuir zoom">üîç-</button>
              <button class="zoom-btn" onclick="zoomImage(1)" title="Aumentar zoom">üîç+</button>
              <button class="zoom-btn" onclick="resetZoom()" title="Resetar zoom">‚åÇ</button>
            </div>
          </div>
          <div class="carousel-dots" id="carouselDots">
            ${product.images.map((_: string, idx: number) => `
              <span class="dot ${idx === 0 ? 'active' : ''}" onclick="currentCarouselImage(${idx + 1})"></span>
            `).join('')}
          </div>
        </div>
      </div>
    </div>
  `;
  
  // Add modal to body
  document.body.insertAdjacentHTML('beforeend', modalHTML);
  
  // Store current image index and zoom state
  (window as any).currentImageIndex = 0;
  (window as any).totalImages = product.images.length;
  (window as any).currentZoomLevel = 0; // 0 = normal, 1 = zoomed (same as gallery modal)
  (window as any).imagePosition = { x: 0, y: 0 };
  
  // Setup carousel dragging after modal is added to DOM
  setTimeout(() => setupCarouselDrag(), 50);
};

(window as any).closeProductModal = function() {
  // Cleanup carousel drag events
  if ((window as any).cleanupCarouselDrag) {
    (window as any).cleanupCarouselDrag();
    (window as any).cleanupCarouselDrag = null;
  }
  
  const modal = document.getElementById('productModal');
  if (modal) {
    modal.remove();
  }
};

(window as any).changeCarouselImage = function(direction: number) {
  const slides = document.querySelectorAll('.carousel-slide');
  const dots = document.querySelectorAll('.dot');
  
  // Remove active class from current slide and dot
  slides[(window as any).currentImageIndex].classList.remove('active');
  dots[(window as any).currentImageIndex].classList.remove('active');
  
  // Update index
  (window as any).currentImageIndex = ((window as any).currentImageIndex + direction + (window as any).totalImages) % (window as any).totalImages;
  
  // Add active class to new slide and dot
  slides[(window as any).currentImageIndex].classList.add('active');
  dots[(window as any).currentImageIndex].classList.add('active');
  
  // Reset zoom when changing images
  (window as any).resetZoom();
};

(window as any).currentCarouselImage = function(imageIndex: number) {
  const slides = document.querySelectorAll('.carousel-slide');
  const dots = document.querySelectorAll('.dot');
  
  // Remove active class from current slide and dot
  slides[(window as any).currentImageIndex].classList.remove('active');
  dots[(window as any).currentImageIndex].classList.remove('active');
  
  // Update index
  (window as any).currentImageIndex = imageIndex - 1;
  
  // Add active class to new slide and dot
  slides[(window as any).currentImageIndex].classList.add('active');
  dots[(window as any).currentImageIndex].classList.add('active');
  
  // Reset zoom when changing images
  (window as any).resetZoom();
};

(window as any).openPhysicsView = function(productType: 'baunilha' | 'parmesao') {
  // Create physics modal HTML
  const modalHTML = `
    <div id="physicsModal" class="modal physics-modal">
      <div class="modal-content physics-content">
        <div class="modal-header">
          <h2>Dentro do Pacote - ${productType === 'baunilha' ? 'Baunilha' : 'Parmes√£o'}</h2>
          <button class="close-modal" onclick="closePhysicsModal()">&times;</button>
        </div>
        <div class="physics-container">
          <canvas id="physicsCanvas"></canvas>
        </div>
      </div>
    </div>
  `;
  
  // Add modal to body
  document.body.insertAdjacentHTML('beforeend', modalHTML);
  
  // Initialize physics simulation
  setTimeout(() => initPhysicsSimulation(productType), 100);
};

(window as any).closePhysicsModal = function() {
  // Cleanup interaction events
  if ((window as any).physicsCleanupInteraction) {
    (window as any).physicsCleanupInteraction();
    (window as any).physicsCleanupInteraction = null;
  }
  
  // Cleanup boundary check interval
  if ((window as any).physicsBoundaryCheckInterval) {
    clearInterval((window as any).physicsBoundaryCheckInterval);
    (window as any).physicsBoundaryCheckInterval = null;
  }
  
  // Stop physics engine
  if ((window as any).physicsEngine) {
    const Matter = (window as any).Matter;
    Matter.Render.stop((window as any).physicsRender);
    Matter.World.clear((window as any).physicsEngine.world, false);
    Matter.Engine.clear((window as any).physicsEngine);
    (window as any).physicsEngine = null;
    (window as any).physicsMouseConstraint = null;
  }
  
  const modal = document.getElementById('physicsModal');
  if (modal) {
    modal.remove();
  }
};

function initPhysicsSimulation(productType: 'baunilha' | 'parmesao') {
  // Load Matter.js if not already loaded
  if (!(window as any).Matter) {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js';
    script.onload = () => createPhysicsWorld(productType);
    document.head.appendChild(script);
  } else {
    createPhysicsWorld(productType);
  }
}

function setupPhysicsInteraction(canvas: HTMLCanvasElement, engine: any) {
  const Matter = (window as any).Matter;
  const Mouse = Matter.Mouse;
  const MouseConstraint = Matter.MouseConstraint;
  const World = Matter.World;
  
  // Create mouse/touch input
  const mouse = Mouse.create(canvas);
  
  // Create mouse constraint for dragging
  const mouseConstraint = MouseConstraint.create(engine, {
    mouse: mouse,
    constraint: {
      stiffness: 0.1, // Lower stiffness for gentler dragging
      damping: 0.9,   // Add damping to reduce violent movements
      length: 0,      // Keep constraint length at zero
      render: {
        visible: false
      }
    }
  });
  
  // Add mouse constraint to world
  World.add(engine.world, mouseConstraint);
  
  mouseConstraint.mouse.element.removeEventListener('wheel', mouseConstraint.mouse.mousewheel);
  mouseConstraint.mouse.element.removeEventListener('DOMMouseScroll', mouseConstraint.mouse.mousewheel);

  let scrollTimeout: any;
  function handleScroll() {
    canvas.style.pointerEvents = "none";
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {
      canvas.style.pointerEvents = "auto";
    }, 200);
  }

  canvas.addEventListener("wheel", handleScroll);

  // Store mouse constraint globally for cleanup
  (window as any).physicsMouseConstraint = mouseConstraint;
  
  // Add click/touch interaction for impulse effects
  const handleInteractionStart = (event: MouseEvent | TouchEvent) => {
    const rect = canvas.getBoundingClientRect();
    
    let clientX, clientY;
    if ('touches' in event) {
      clientX = event.touches[0].clientX;
      clientY = event.touches[0].clientY;
    } else {
      clientX = event.clientX;
      clientY = event.clientY;
    }
    
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    
    // Apply force to nearby biscuits
    applyForceAtPosition(x, y);
  };
  
  const handleInteractionEnd = () => {
    // End interaction (could be used for visual feedback later)
  };
  
  // Add event listeners for mouse and touch
  canvas.addEventListener('mousedown', handleInteractionStart);
  canvas.addEventListener('mouseup', handleInteractionEnd);
  canvas.addEventListener('touchstart', handleInteractionStart, { passive: true });
  canvas.addEventListener('touchend', handleInteractionEnd);
  
  // Prevent context menu on right click
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());
  
  // Store cleanup function
  (window as any).physicsCleanupInteraction = () => {
    canvas.removeEventListener('mousedown', handleInteractionStart);
    canvas.removeEventListener('mouseup', handleInteractionEnd);
    canvas.removeEventListener('touchstart', handleInteractionStart);
    canvas.removeEventListener('touchend', handleInteractionEnd);
    canvas.removeEventListener('contextmenu', (e) => e.preventDefault());
  };
}

function applyForceAtPosition(x: number, y: number) {
  if (!(window as any).physicsBiscuits) return;
  
  const Matter = (window as any).Matter;
  const forceRadius = 60; // Radius of effect
  const maxForce = 0.02; // Maximum force intensity
  
  (window as any).physicsBiscuits.forEach((biscuit: any) => {
    const dx = biscuit.position.x - x;
    const dy = biscuit.position.y - y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < forceRadius && distance > 0) {
      // Calculate force based on distance (closer = stronger)
      const forceMagnitude = (forceRadius - distance) / forceRadius * maxForce;
      
      // Normalize direction and apply force
      const forceX = (dx / distance) * forceMagnitude;
      const forceY = (dy / distance) * forceMagnitude;
      
      // Add some randomness for more natural movement
      const randomX = (Math.random() - 0.5) * 0.005;
      const randomY = (Math.random() - 0.5) * 0.005;
      
      Matter.Body.applyForce(biscuit, biscuit.position, {
        x: forceX + randomX,
        y: forceY + randomY
      });
      
      // Add slight rotation for visual effect
      Matter.Body.setAngularVelocity(biscuit, (Math.random() - 0.5) * 0.1);
    }
  });
}

function setupBoundaryCheck(canvas: HTMLCanvasElement, biscuits: any[]) {
  const Matter = (window as any).Matter;
  
  // Create boundary check interval
  const boundaryCheckInterval = setInterval(() => {
    if (!(window as any).physicsEngine || !biscuits.length) {
      clearInterval(boundaryCheckInterval);
      return;
    }
    
    biscuits.forEach((biscuit: any) => {
      const pos = biscuit.position;
      const margin = 10; // Safety margin from edges
      let needsReset = false;
      let newX = pos.x;
      let newY = pos.y;
      
      // Check if biscuit is outside canvas bounds
      if (pos.x < margin) {
        newX = margin + Math.random() * 50; // Random position near left edge
        needsReset = true;
      } else if (pos.x > canvas.width - margin) {
        newX = canvas.width - margin - Math.random() * 50; // Random position near right edge
        needsReset = true;
      }
      
      if (pos.y < margin) {
        newY = margin + Math.random() * 50; // Random position near top
        needsReset = true;
      } else if (pos.y > canvas.height - margin) {
        newY = canvas.height - margin - Math.random() * 50; // Random position near bottom
        needsReset = true;
      }
      
      // Reset position and velocity if biscuit escaped
      if (needsReset) {
        Matter.Body.setPosition(biscuit, { x: newX, y: newY });
        Matter.Body.setVelocity(biscuit, { x: 0, y: 0 });
        Matter.Body.setAngularVelocity(biscuit, 0);
      }
    });
  }, 100); // Check every 100ms
  
  // Store interval for cleanup
  (window as any).physicsBoundaryCheckInterval = boundaryCheckInterval;
}

function createPhysicsWorld(productType: 'baunilha' | 'parmesao') {
  const Matter = (window as any).Matter;
  const Engine = Matter.Engine;
  const Render = Matter.Render;
  const World = Matter.World;
  const Bodies = Matter.Bodies;
  
  const canvas = document.getElementById('physicsCanvas') as HTMLCanvasElement;
  const containerRect = canvas.parentElement!.getBoundingClientRect();
  
  canvas.width = containerRect.width - 40;
  canvas.height = 400;
  
  // Create engine
  const engine = Engine.create();
  engine.world.gravity.y = 0.5;
  
  // Create renderer
  const render = Render.create({
    canvas: canvas,
    engine: engine,
    options: {
      width: canvas.width,
      height: canvas.height,
      wireframes: false,
      background: '#FFF8DC'
    }
  });
  
  // Create boundaries (thicker invisible walls to prevent escape)
  const wallThickness = 50; // Much thicker walls
  const walls = [
    // Top wall
    Bodies.rectangle(canvas.width / 2, -wallThickness/2, canvas.width + wallThickness*2, wallThickness, { isStatic: true, render: { visible: false } }),
    // Bottom wall
    Bodies.rectangle(canvas.width / 2, canvas.height + wallThickness/2, canvas.width + wallThickness*2, wallThickness, { isStatic: true, render: { visible: false } }),
    // Left wall
    Bodies.rectangle(-wallThickness/2, canvas.height / 2, wallThickness, canvas.height + wallThickness*2, { isStatic: true, render: { visible: false } }),
    // Right wall
    Bodies.rectangle(canvas.width + wallThickness/2, canvas.height / 2, wallThickness, canvas.height + wallThickness*2, { isStatic: true, render: { visible: false } })
  ];
  
  // Create biscuits based on product type
  const biscuits: any[] = [];
  
  if (productType === 'baunilha') {
    // 1 dinosaur, 6 hearts, 6 flowers, 5 stars
    const biscuitConfigs = [
      { count: 1, type: 'dinosaur', image: '/biscuits/biscoidino_biscuit1.png' },
      { count: 2, type: 'flower1', image: '/biscuits/flower_baunilha1.png' },
      { count: 2, type: 'flower2', image: '/biscuits/flower_baunilha2.png' },
      { count: 2, type: 'heart1', image: '/biscuits/heart_baunilha1.png' },
      { count: 2, type: 'heart2', image: '/biscuits/heart_baunilha2.png' },
      { count: 2, type: 'star1', image: '/biscuits/star_baunilha1.png' },
      { count: 3, type: 'star2', image: '/biscuits/star_baunilha2.png' }
    ];
    
    biscuitConfigs.forEach(config => {
      for (let i = 0; i < config.count; i++) {
        const x = Math.random() * (canvas.width - 100) + 50;
        const y = Math.random() * 100 + 50;
        
        const biscuit = createStandardBiscuit(Matter, x, y, config.image, {
          restitution: 0.3,
          friction: 0.4
        });
        
        biscuits.push(biscuit);
      }
    });
  } else {
    // 21 parmes√£o biscuits - mix of both types
    for (let i = 0; i < 21; i++) {
      const x = Math.random() * (canvas.width - 100) + 50;
      const y = Math.random() * 150 + 50;
      
      // Alternate between the two new parmesao biscuit package types
      const biscuitType = i % 2 === 0 ? '/biscuits/parmesao_biscuit1.png' : '/biscuits/parmesao_biscuit2.png';
      
      const biscuit = createStandardBiscuit(Matter, x, y, biscuitType, {
        restitution: 0.2,
        friction: 0.5
      });
      
      biscuits.push(biscuit);
    }
  }
  
  // Add all bodies to world
  World.add(engine.world, [...walls, ...biscuits]);
  
  // Store references globally
  (window as any).physicsEngine = engine;
  (window as any).physicsRender = render;
  (window as any).physicsBiscuits = biscuits;
  
  // Add mouse/touch interaction
  setupPhysicsInteraction(canvas, engine);
  
  // Add boundary check system
  setupBoundaryCheck(canvas, biscuits);
  
  // Start simulation
  Engine.run(engine);
  Render.run(render);
}

(window as any).shakeBiscuits = function() {
  if ((window as any).physicsBiscuits) {
    const Matter = (window as any).Matter;
    (window as any).physicsBiscuits.forEach((biscuit: any) => {
      const force = {
        x: (Math.random() - 0.5) * 0.01,
        y: (Math.random() - 0.5) * 0.01
      };
      Matter.Body.applyForce(biscuit, biscuit.position, force);
    });
  }
};

(window as any).resetBiscuits = function() {
  if ((window as any).physicsBiscuits && (window as any).physicsEngine) {
    const canvas = document.getElementById('physicsCanvas') as HTMLCanvasElement;
    (window as any).physicsBiscuits.forEach((biscuit: any) => {
      const x = Math.random() * (canvas.width - 100) + 50;
      const y = Math.random() * 100 + 50;
      const Matter = (window as any).Matter;
      Matter.Body.setPosition(biscuit, { x, y });
      Matter.Body.setVelocity(biscuit, { x: 0, y: 0 });
    });
  }
};

// Zoom and carousel drag functions
(window as any).zoomImage = function(direction: number) {
  const currentLevel = (window as any).currentZoomLevel || 0;
  const newLevel = Math.max(0, Math.min(1, currentLevel + direction));
  
  (window as any).currentZoomLevel = newLevel;
  (window as any).imagePosition = { x: 0, y: 0 }; // Reset position when changing zoom
  updateImageTransform();
};

(window as any).resetZoom = function() {
  (window as any).currentZoomLevel = 0;
  (window as any).imagePosition = { x: 0, y: 0 };
  updateImageTransform();
};

function updateImageTransform() {
  const activeSlide = document.querySelector('.carousel-slide.active');
  if (activeSlide) {
    const img = activeSlide.querySelector('.carousel-image') as HTMLImageElement;
    if (img) {
      const zoomLevel = (window as any).currentZoomLevel || 0;
      const position = (window as any).imagePosition || { x: 0, y: 0 };
      
      // Simple 2-level zoom: 1x and 2x (same as gallery modal)
      const scale = zoomLevel === 0 ? 1 : 2;
      
      img.style.transform = `scale(${scale}) translate(${position.x}px, ${position.y}px)`;
      img.style.cursor = zoomLevel > 0 ? 'move' : 'zoom-in';
    }
  }
}

function setupCarouselDrag() {
  const carouselContainer = document.getElementById('carouselImages');
  if (!carouselContainer) return;
  
  let isDragging = false;
  let isImageDrag = false;
  let startX = 0;
  let startY = 0;
  let endX = 0;
  let initialImagePos = { x: 0, y: 0 };
  
  // Handle mouse and touch events for carousel dragging
  const handleStart = (e: MouseEvent | TouchEvent) => {
    isDragging = true;
    
    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
    
    startX = clientX;
    startY = clientY;
    endX = clientX;
    
    // Check if we're dragging a zoomed image
    const activeImg = document.querySelector('.carousel-slide.active .carousel-image') as HTMLElement;
    if (activeImg && (window as any).currentZoomLevel > 0) {
      isImageDrag = true;
      initialImagePos = { ...(window as any).imagePosition };
      activeImg.style.cursor = 'grabbing';
    } else {
      isImageDrag = false;
      carouselContainer.style.cursor = 'grabbing';
    }
    
    e.preventDefault();
  };
  
  const handleMove = (e: MouseEvent | TouchEvent) => {
    if (!isDragging) return;
    
    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
    
    endX = clientX; // Track current position for end calculation
    
    if (isImageDrag && (window as any).currentZoomLevel > 0) {
      // Drag zoomed image - use scale 2 for calculations
      const deltaX = (clientX - startX) / 2;
      const deltaY = (clientY - startY) / 2;
      
      (window as any).imagePosition = {
        x: initialImagePos.x + deltaX,
        y: initialImagePos.y + deltaY
      };
      
      updateImageTransform();
    }
    
    e.preventDefault();
  };
  
  const handleEnd = () => {
    if (!isDragging) return;
    
    isDragging = false;
    
    const activeImg = document.querySelector('.carousel-slide.active .carousel-image') as HTMLElement;
    if (activeImg) {
      activeImg.style.cursor = (window as any).currentZoomLevel > 0 ? 'move' : 'zoom-in';
    }
    carouselContainer.style.cursor = 'grab';
    
    // Handle carousel navigation if not dragging zoomed image
    if (!isImageDrag) {
      const dragDistance = endX - startX;
      const threshold = 50; // Minimum drag distance to change slides
      
      if (Math.abs(dragDistance) > threshold) {
        if (dragDistance > 0) {
          // Dragged right -> go to previous image
          (window as any).changeCarouselImage(-1);
        } else {
          // Dragged left -> go to next image
          (window as any).changeCarouselImage(1);
        }
      }
    }
    
    isImageDrag = false;
  };
  
  // Set initial cursor style to indicate draggable
  carouselContainer.style.cursor = 'grab';
  
  // Add event listeners
  carouselContainer.addEventListener('mousedown', handleStart);
  carouselContainer.addEventListener('touchstart', handleStart, { passive: false });
  
  document.addEventListener('mousemove', handleMove);
  document.addEventListener('touchmove', handleMove, { passive: false });
  
  document.addEventListener('mouseup', handleEnd);
  document.addEventListener('touchend', handleEnd);
  
  // Prevent drag on images to avoid browser's default drag behavior
  const images = carouselContainer.querySelectorAll('img');
  images.forEach(img => {
    img.addEventListener('dragstart', (e) => e.preventDefault());
    img.style.userSelect = 'none';
    img.style.webkitUserSelect = 'none';
  });
  
  // Add pinch-to-zoom support for mobile
  let initialDistance = 0;
  
  const handleTouchStart = (e: TouchEvent) => {
    if (e.touches.length === 2) {
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
    }
  };
  
  const handleTouchMove = (e: TouchEvent) => {
    if (e.touches.length === 2 && initialDistance > 0) {
      e.preventDefault();
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
      
      const scale = currentDistance / initialDistance;
      
      if (scale > 1.2 && (window as any).currentZoomLevel === 0) {
        // Pinch out - zoom in
        (window as any).zoomImage(1);
      } else if (scale < 0.8 && (window as any).currentZoomLevel === 1) {
        // Pinch in - zoom out
        (window as any).zoomImage(-1);
      }
    }
  };
  
  const handleTouchEnd = (e: TouchEvent) => {
    if (e.touches.length < 2) {
      initialDistance = 0;
    }
  };
  
  // Add pinch event listeners to carousel images
  images.forEach(img => {
    img.addEventListener('touchstart', handleTouchStart, { passive: false });
    img.addEventListener('touchmove', handleTouchMove, { passive: false });
    img.addEventListener('touchend', handleTouchEnd);
  });
  
  // Store cleanup function
  (window as any).cleanupCarouselDrag = () => {
    carouselContainer.removeEventListener('mousedown', handleStart);
    carouselContainer.removeEventListener('touchstart', handleStart);
    document.removeEventListener('mousemove', handleMove);
    document.removeEventListener('touchmove', handleMove);
    document.removeEventListener('mouseup', handleEnd);
    document.removeEventListener('touchend', handleEnd);
    
    images.forEach(img => {
      img.removeEventListener('dragstart', (e) => e.preventDefault());
      img.removeEventListener('touchstart', handleTouchStart);
      img.removeEventListener('touchmove', handleTouchMove);
      img.removeEventListener('touchend', handleTouchEnd);
    });
  };
}

// Gallery Carousel Functions
let currentGallerySlide = 0;
const totalGallerySlides = 9;

(window as any).galleryNextSlide = function() {
  currentGallerySlide = (currentGallerySlide + 1) % totalGallerySlides;
  updateGallerySlide();
};

(window as any).galleryPrevSlide = function() {
  currentGallerySlide = (currentGallerySlide - 1 + totalGallerySlides) % totalGallerySlides;
  updateGallerySlide();
};

(window as any).galleryGoToSlide = function(index: number) {
  currentGallerySlide = index;
  updateGallerySlide();
};

function updateGallerySlide() {
  const slides = document.querySelectorAll('.gallery-slide');
  const indicators = document.querySelectorAll('.gallery-indicator');
  
  if (slides.length === 0) return;
  
  // Calcular √≠ndices do carrossel infinito
  const prevSlideIndex = (currentGallerySlide - 1 + totalGallerySlides) % totalGallerySlides;
  const nextSlideIndex = (currentGallerySlide + 1) % totalGallerySlides;
  
  console.log('üéØ Updating gallery slide:', {
    current: currentGallerySlide,
    prev: prevSlideIndex,
    next: nextSlideIndex,
    totalSlides: slides.length
  });
  
  // Resetar todos os slides primeiro
  slides.forEach((slideElement) => {
    const slide = slideElement as HTMLElement;
    slide.classList.remove('active', 'prev-slide', 'next-slide');
    slide.style.display = 'none';
  });
  
  // Mostrar apenas os 3 slides necess√°rios
  slides.forEach((slideElement, index) => {
    const slide = slideElement as HTMLElement;
    
    if (index === currentGallerySlide) {
      // Slide ativo (centro)
      slide.style.display = 'block';
      slide.classList.add('active');
    } else if (index === prevSlideIndex) {
      // Slide anterior (esquerda)
      slide.style.display = 'block';
      slide.classList.add('prev-slide');
    } else if (index === nextSlideIndex) {
      // Pr√≥ximo slide (direita)
      slide.style.display = 'block';
      slide.classList.add('next-slide');
    }
  });
  
  // Atualizar indicadores
  indicators.forEach((indicator, index) => {
    if (index === currentGallerySlide) {
      indicator.classList.add('active');
    } else {
      indicator.classList.remove('active');
    }
  });
}

// Gallery Drag/Swipe Functions - COPIADO DO MODAL DOS PRODUTOS
function setupGalleryDrag() {
  const galleryContainer = document.querySelector('.gallery-slides-container') as HTMLElement;
  if (!galleryContainer) return;
  
  let isDragging = false;
  let startX = 0;
  let startY = 0;
  let endX = 0;
  let dragStartTime = 0;
  let hasMoved = false;
  
  // Handle mouse and touch events for gallery dragging
  const handleStart = (e: MouseEvent | TouchEvent) => {
    isDragging = true;
    hasMoved = false;
    dragStartTime = Date.now();
    
    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
    
    startX = clientX;
    startY = clientY;
    endX = clientX;
    
    galleryContainer.style.cursor = 'grabbing';
    e.preventDefault();
  };
  
  const handleMove = (e: MouseEvent | TouchEvent) => {
    if (!isDragging) return;
    
    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
    
    endX = clientX;
    
    // Check if user has moved significantly
    const moveDistance = Math.sqrt(Math.pow(clientX - startX, 2) + Math.pow(clientY - startY, 2));
    if (moveDistance > 10) {
      hasMoved = true;
    }
    
    e.preventDefault();
  };
  
  const handleEnd = (e: MouseEvent | TouchEvent) => {
    if (!isDragging) return;
    
    isDragging = false;
    galleryContainer.style.cursor = 'grab';
    
    const clickDuration = Date.now() - dragStartTime;
    const dragDistance = endX - startX;
    const threshold = 50; // Minimum drag distance to change slides
    
    // If it was a quick tap/click without significant movement, open modal
    if (clickDuration < 300 && !hasMoved) {
      const target = e.target as HTMLElement;
      const slide = target.closest('.gallery-slide.active') as HTMLElement;
      if (slide && slide.dataset.imageSrc) {
        openGalleryImageModal(slide.dataset.imageSrc);
      }
      return;
    }
    
    // Handle gallery navigation only if user dragged significantly
    if (hasMoved && Math.abs(dragDistance) > threshold) {
      if (dragDistance > 0) {
        // Dragged right -> go to previous slide
        (window as any).galleryPrevSlide();
      } else {
        // Dragged left -> go to next slide
        (window as any).galleryNextSlide();
      }
    }
  };
  
  // Set initial cursor style to indicate draggable
  galleryContainer.style.cursor = 'grab';
  
  // Add event listeners
  galleryContainer.addEventListener('mousedown', handleStart);
  galleryContainer.addEventListener('touchstart', handleStart, { passive: false });
  
  document.addEventListener('mousemove', handleMove);
  document.addEventListener('touchmove', handleMove, { passive: false });
  
  document.addEventListener('mouseup', handleEnd);
  document.addEventListener('touchend', handleEnd);
  
  // Prevent drag on images to avoid browser's default drag behavior
  galleryContainer.addEventListener('dragstart', (e) => e.preventDefault());
  galleryContainer.addEventListener('selectstart', (e) => e.preventDefault());
}

// Initialize gallery carousel - will be called after navigation setup
function initializeGalleryCarousel() {
  console.log('üéÆ Initializing Gallery Carousel...');
  
  const slides = document.querySelectorAll('.gallery-slide');
  const container = document.querySelector('.gallery-slides-container');
  
  console.log('üìä Gallery stats:');
  console.log('   - Slides found:', slides.length);
  console.log('   - Container found:', !!container);
  
  if (slides.length === 0) {
    console.warn('‚ö†Ô∏è No gallery slides found!');
    return;
  }
  
  // Force update gallery slide multiple times to ensure it takes effect
  updateGallerySlide();
  setTimeout(() => updateGallerySlide(), 10);
  setTimeout(() => updateGallerySlide(), 50);
  
  setupGalleryDrag();
  
  // Aplicar intelig√™ncia de imagem para cada slide
  setTimeout(() => applyImageIntelligence(), 100);
  
  console.log('‚úÖ Gallery carousel initialized successfully');
}

// Intelig√™ncia para otimizar a exibi√ß√£o das imagens na galeria
function applyImageIntelligence() {
  console.log('üß† Aplicando intelig√™ncia de imagem...');
  
  const slides = document.querySelectorAll('.gallery-slide[data-image-src]');
  
  slides.forEach((slide, index) => {
    const slideElement = slide as HTMLElement;
    const imageSrc = slideElement.dataset.imageSrc;
    
    if (!imageSrc) return;
    
    // Criar elemento de imagem para analisar as dimens√µes
    const img = new Image();
    
    img.onload = function() {
      const aspectRatio = img.naturalWidth / img.naturalHeight;
      const slideAspectRatio = 0.7 / 0.5; // Aproximadamente 1.4 (width 70% / height 500px)
      
      console.log(`üì∏ Imagem ${index + 1}:`, {
        width: img.naturalWidth,
        height: img.naturalHeight,
        aspectRatio: aspectRatio.toFixed(2),
        slideAspectRatio: slideAspectRatio.toFixed(2)
      });
      
      // Determinar a melhor estrat√©gia de exibi√ß√£o
      let backgroundSize = 'contain';
      let backgroundColor = 'var(--background)';
      
      // Se a propor√ß√£o da imagem √© muito similar √† do slide, usar cover
      if (Math.abs(aspectRatio - slideAspectRatio) < 0.3) {
        backgroundSize = 'cover';
        console.log(`‚ú® Imagem ${index + 1}: Propor√ß√£o ideal, usando cover`);
      } else if (aspectRatio > slideAspectRatio) {
        // Imagem mais larga - usar contain com fundo suave
        backgroundSize = 'contain';
        backgroundColor = 'linear-gradient(135deg, var(--background), var(--primary-color)15%)';
        console.log(`üìê Imagem ${index + 1}: Muito larga, usando contain com gradiente`);
      } else {
        // Imagem mais alta - usar contain com fundo neutro
        backgroundSize = 'contain';
        backgroundColor = 'var(--background)';
        console.log(`üìè Imagem ${index + 1}: Muito alta, usando contain com fundo neutro`);
      }
      
      // Aplicar estilos otimizados
      slideElement.style.backgroundImage = `url('${imageSrc}')`;
      slideElement.style.backgroundSize = backgroundSize;
      slideElement.style.background = `${backgroundColor} url('${imageSrc}') center/contain no-repeat`;
      
      // Se usar contain, adicionar uma borda sutil para definir melhor o slide
      if (backgroundSize === 'contain') {
        slideElement.style.border = '2px solid rgba(255, 182, 191, 0.2)';
      }
    };
    
    img.onerror = function() {
      console.error(`‚ùå Erro ao carregar imagem: ${imageSrc}`);
      // Fallback para imagem com erro
      slideElement.style.background = 'var(--background)';
      slideElement.style.display = 'flex';
      slideElement.style.alignItems = 'center';
      slideElement.style.justifyContent = 'center';
      slideElement.innerHTML = '<div style="color: var(--text-light); text-align: center;">Imagem n√£o encontrada</div>';
    };
    
    img.src = imageSrc;
  });
}

// Gallery Image Modal Functions
function openGalleryImageModal(imageSrc: string) {
  const modalHTML = `
    <div id="galleryImageModal" class="modal gallery-image-modal">
      <div class="modal-content gallery-modal-content">
        <div class="modal-header">
          <h2>Galeria</h2>
          <button class="close-modal" onclick="closeGalleryImageModal()">&times;</button>
        </div>
        <div class="gallery-image-container">
          <img id="galleryModalImage" src="${imageSrc}" alt="Imagem da galeria" class="gallery-modal-image" />
          <div class="zoom-controls gallery-zoom-controls">
            <button class="zoom-btn gallery-zoom-btn" onclick="galleryZoomImage(-1)" title="Diminuir zoom">üîç-</button>
            <button class="zoom-btn gallery-zoom-btn" onclick="galleryZoomImage(1)" title="Aumentar zoom">üîç+</button>
            <button class="zoom-btn gallery-zoom-btn" onclick="galleryResetZoom()" title="Resetar zoom">‚åÇ</button>
          </div>
        </div>
      </div>
    </div>
  `;
  
  document.body.insertAdjacentHTML('beforeend', modalHTML);
  
  // Initialize zoom state
  (window as any).galleryZoomLevel = 0; // 0 = normal, 1 = zoomed
  (window as any).galleryImagePosition = { x: 0, y: 0 };
  
  // Setup interactions
  setTimeout(() => setupGalleryModalInteractions(), 50);
}

(window as any).closeGalleryImageModal = function() {
  const modal = document.getElementById('galleryImageModal');
  if (modal) {
    document.body.removeChild(modal);
  }
  
  // Cleanup event listeners
  if ((window as any).galleryModalCleanup) {
    (window as any).galleryModalCleanup();
  }
};

(window as any).galleryZoomImage = function(direction: number) {
  const currentLevel = (window as any).galleryZoomLevel || 0;
  const newLevel = Math.max(0, Math.min(1, currentLevel + direction));
  
  (window as any).galleryZoomLevel = newLevel;
  updateGalleryImageTransform();
};

(window as any).galleryResetZoom = function() {
  (window as any).galleryZoomLevel = 0;
  (window as any).galleryImagePosition = { x: 0, y: 0 };
  updateGalleryImageTransform();
};

function updateGalleryImageTransform() {
  const image = document.getElementById('galleryModalImage') as HTMLImageElement;
  if (!image) return;
  
  const zoomLevel = (window as any).galleryZoomLevel || 0;
  const position = (window as any).galleryImagePosition || { x: 0, y: 0 };
  
  // Simple 2-level zoom: 1x and 2x
  const scale = zoomLevel === 0 ? 1 : 2;
  
  image.style.transform = `scale(${scale}) translate(${position.x}px, ${position.y}px)`;
  image.style.cursor = zoomLevel > 0 ? 'move' : 'zoom-in';
}

function setupGalleryModalInteractions() {
  const image = document.getElementById('galleryModalImage') as HTMLImageElement;
  const container = image.parentElement as HTMLElement;
  
  if (!image || !container) return;
  
  let isDragging = false;
  let startX = 0;
  let startY = 0;
  let initialPosition = { x: 0, y: 0 };
  
  // Desktop mouse interactions
  const handleMouseDown = (e: MouseEvent) => {
    const zoomLevel = (window as any).galleryZoomLevel || 0;
    
    if (zoomLevel === 0) {
      // Not zoomed, zoom in on click
      (window as any).galleryZoomImage(1);
      return;
    }
    
    // Zoomed in, allow dragging
    isDragging = true;
    startX = e.clientX;
    startY = e.clientY;
    initialPosition = { ...(window as any).galleryImagePosition };
    e.preventDefault();
  };
  
  const handleMouseMove = (e: MouseEvent) => {
    const zoomLevel = (window as any).galleryZoomLevel || 0;
    if (!isDragging || zoomLevel === 0) return;
    
    const deltaX = (e.clientX - startX) / 2; // Reduce sensitivity
    const deltaY = (e.clientY - startY) / 2;
    
    (window as any).galleryImagePosition = {
      x: initialPosition.x + deltaX,
      y: initialPosition.y + deltaY
    };
    
    updateGalleryImageTransform();
  };
  
  const handleMouseUp = () => {
    isDragging = false;
  };
  
  // Touch interactions for mobile
  let initialDistance = 0;
  
  const handleTouchStart = (e: TouchEvent) => {
    e.preventDefault();
    
    if (e.touches.length === 2) {
      // Pinch gesture
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      initialDistance = Math.sqrt(
        Math.pow(touch2.clientX - touch1.clientX, 2) + 
        Math.pow(touch2.clientY - touch1.clientY, 2)
      );
    } else if (e.touches.length === 1) {
      // Single touch
      const zoomLevel = (window as any).galleryZoomLevel || 0;
      if (zoomLevel === 0) {
        // Not zoomed, zoom in on tap
        (window as any).galleryZoomImage(1);
      } else {
        // Zoomed in, prepare for dragging
        isDragging = true;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        initialPosition = { ...(window as any).galleryImagePosition };
      }
    }
  };
  
  const handleTouchMove = (e: TouchEvent) => {
    e.preventDefault();
    
    if (e.touches.length === 2) {
      // Pinch zoom
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const currentDistance = Math.sqrt(
        Math.pow(touch2.clientX - touch1.clientX, 2) + 
        Math.pow(touch2.clientY - touch1.clientY, 2)
      );
      
      const scale = currentDistance / initialDistance;
      const newZoom = scale > 1.2 ? 1 : 0; // Simple threshold
      
      if (newZoom !== (window as any).galleryZoomLevel) {
        (window as any).galleryZoomLevel = newZoom;
        updateGalleryImageTransform();
      }
    } else if (e.touches.length === 1 && isDragging) {
      // Pan when zoomed
      const zoomLevel = (window as any).galleryZoomLevel || 0;
      if (zoomLevel > 0) {
        const deltaX = (e.touches[0].clientX - startX) / 2;
        const deltaY = (e.touches[0].clientY - startY) / 2;
        
        (window as any).galleryImagePosition = {
          x: initialPosition.x + deltaX,
          y: initialPosition.y + deltaY
        };
        
        updateGalleryImageTransform();
      }
    }
  };
  
  const handleTouchEnd = (e: TouchEvent) => {
    if (e.touches.length === 0) {
      isDragging = false;
    }
  };
  
  // Add event listeners
  image.addEventListener('mousedown', handleMouseDown);
  document.addEventListener('mousemove', handleMouseMove);
  document.addEventListener('mouseup', handleMouseUp);
  
  image.addEventListener('touchstart', handleTouchStart, { passive: false });
  document.addEventListener('touchmove', handleTouchMove, { passive: false });
  document.addEventListener('touchend', handleTouchEnd, { passive: false });
  
  // Prevent context menu
  image.addEventListener('contextmenu', (e) => e.preventDefault());
  
  // Store cleanup function
  (window as any).galleryModalCleanup = () => {
    image.removeEventListener('mousedown', handleMouseDown);
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
    
    image.removeEventListener('touchstart', handleTouchStart);
    document.removeEventListener('touchmove', handleTouchMove);
    document.removeEventListener('touchend', handleTouchEnd);
    
    image.removeEventListener('contextmenu', (e) => e.preventDefault());
  };
  
  // Initialize transform
  updateGalleryImageTransform();
}

// Centralized Biscuit Configuration
function getBiscuitConfig(texture: string) {
  const radiusMap: any = {
    '/biscuits/parmesao_biscuit1.png': 27,
    '/biscuits/parmesao_biscuit2.png': 27,
    '/biscuits/biscoidino_biscuit1.png': 45,
    '/biscuits/heart_baunilha1.png': 28,
    '/biscuits/star_baunilha1.png': 30,
    '/biscuits/flower_baunilha1.png': 35,
    '/biscuits/heart_baunilha2.png': 28,
    '/biscuits/star_baunilha2.png': 30,
    '/biscuits/flower_baunilha2.png': 35,
    'default': 25
  };

  const scaleMap: any = {
    '/biscuits/parmesao_biscuit1.png': 0.25,
    '/biscuits/parmesao_biscuit2.png': 0.25,
    '/biscuits/biscoidino_biscuit1.png': 0.42,
    '/biscuits/heart_baunilha1.png': 0.35,
    '/biscuits/star_baunilha1.png': 0.4,
    '/biscuits/flower_baunilha1.png': 0.35,
    '/biscuits/heart_baunilha2.png': 0.35,
    '/biscuits/star_baunilha2.png': 0.4,
    '/biscuits/flower_baunilha2.png': 0.35,
    'default': 0.3
  };

  return {
    radius: radiusMap[texture] || radiusMap['default'],
    scale: scaleMap[texture] || scaleMap['default']
  };
}

function createStandardBiscuit(Matter: any, x: number, y: number, texture: string, physicsOptions: any = {}) {
  const config = getBiscuitConfig(texture);
  const Bodies = Matter.Bodies;
  
  const defaultPhysics = {
    restitution: 0.6,
    frictionAir: 0.01,
    density: 0.002
  };

  return Bodies.circle(x, y, config.radius, { 
    ...defaultPhysics,
    ...physicsOptions,
    render: { 
      sprite: {
        texture: texture,
        xScale: config.scale,
        yScale: config.scale
      }
    }
  });
}

// Home Physics Functions
function initHomePhysics() {
  console.log('üåü Initializing Home Physics with Matter.js...');
  
  // Load Matter.js if not already loaded
  if (!(window as any).Matter) {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js';
    script.onload = () => createHomePhysicsWorld();
    document.head.appendChild(script);
  } else {
    createHomePhysicsWorld();
  }
}

function createHomePhysicsWorld() {
  const Matter = (window as any).Matter;
  const Engine = Matter.Engine;
  const Render = Matter.Render;
  const World = Matter.World;
  const Bodies = Matter.Bodies;
  
  const canvas = document.getElementById('homePhysicsCanvas') as HTMLCanvasElement;
  const container = document.getElementById('homeImageContainer') as HTMLElement;
  
  if (!canvas || !container) {
    console.error('‚ùå Canvas ou container n√£o encontrado');
    return;
  }
  
  // Get container size and set canvas dimensions properly for crisp rendering
  const containerRect = container.getBoundingClientRect();
  const pixelRatio = window.devicePixelRatio || 1;
  
  // Set actual canvas size (for crisp rendering)
  canvas.width = containerRect.width * pixelRatio;
  canvas.height = containerRect.height * pixelRatio;
  
  // Scale canvas back down using CSS for proper display size
  canvas.style.width = containerRect.width + 'px';
  canvas.style.height = containerRect.height + 'px';
  
  // Get the context and scale it for high DPI displays
  const ctx = canvas.getContext('2d');
  if (ctx) {
    ctx.scale(pixelRatio, pixelRatio);
  }
  
  // Store initial canvas size for resize detection
  (window as any).homeLastCanvasSize = { 
    width: Math.round(containerRect.width), 
    height: Math.round(containerRect.height) 
  };

  console.log('üìê Home physics canvas:', {
    displayWidth: containerRect.width, 
    displayHeight: containerRect.height,
    actualWidth: canvas.width, 
    actualHeight: canvas.height,
    pixelRatio: pixelRatio
  });
  
  // Create engine with natural gravity
  const engine = Engine.create();
  engine.world.gravity.y = 0.3;
  
  // Create renderer with sprites (use display dimensions, not actual canvas dimensions)
  const render = Render.create({
    canvas: canvas,
    engine: engine,
    options: {
      width: containerRect.width,
      height: containerRect.height,
      wireframes: false,
      background: 'transparent',
      showAngleIndicator: false,
      showDebug: false,
      showVelocity: false,
      showIds: false,
      showShadows: false,
      showVertexNumbers: false,
      showConvexHulls: false
    }
  });
  
  // Create boundaries within the canvas area (use display dimensions)
  const wallThickness = 10;
  const displayWidth = containerRect.width;
  const displayHeight = containerRect.height;
  
  const walls = [
    // Bottom wall (floor)
    Bodies.rectangle(displayWidth / 2, (displayHeight - wallThickness/2) - 20, displayWidth, wallThickness, { 
      isStatic: true, 
      render: { visible: false } 
    }),
    // Left wall
    Bodies.rectangle(wallThickness/2 + 20, displayHeight / 2, wallThickness, displayHeight, { 
      isStatic: true, 
      render: { visible: false } 
    }),
    // Right wall
    Bodies.rectangle((displayWidth - wallThickness/2) - 20, displayHeight / 2, wallThickness, displayHeight, { 
      isStatic: true, 
      render: { visible: false } 
    }),
    Bodies.rectangle(displayWidth / 2, 20, displayWidth, wallThickness, { 
      isStatic: true, 
      render: { visible: false } 
    }),
  ];
  
  // Create home biscuits with physics (use display dimensions)
  const homeBiscuits = createHomeBiscuits(displayWidth, displayHeight);

  // Add all bodies to world
  World.add(engine.world, [...walls, ...homeBiscuits]);  // Store references globally for interaction
  (window as any).homePhysicsEngine = engine;
  (window as any).homePhysicsRender = render;
  (window as any).homePhysicsBiscuits = homeBiscuits;

  // Setup home interaction
  setupHomePhysicsInteraction(canvas, engine);
  
  // Start simulation
  Engine.run(engine);
  Render.run(render);
  
  // Setup resize listener for responsive canvas (only once)
  if (!(window as any).homeResizeSetup) {
    setupHomeCanvasResize();
    (window as any).homeResizeSetup = true;
  }

  console.log('‚úÖ Home physics initialized successfully');
}

function createHomeBiscuits(canvasWidth: number, canvasHeight: number) {
  const Matter = (window as any).Matter;
  
  const centerX = canvasWidth / 2;
  
  // Check if we have saved biscuit states from resize
  const savedStates = (window as any).homeBiscuitStates;
  let useDefaultPositions = !savedStates || savedStates.length === 0;
  
  // Default positions for first load - distributed equally across 3 formats
  const defaultPositions = [
    { x: centerX + 100, y: 20, texture: '/biscuits/biscoidino_biscuit1.png' },
    { x: centerX - 100, y: 50, texture: '/biscuits/flower_baunilha1.png' },
    { x: centerX - 100, y: 50, texture: '/biscuits/flower_baunilha2.png' },
    { x: centerX + 80, y: 60, texture: '/biscuits/heart_baunilha1.png' },
    { x: centerX + 80, y: 60, texture: '/biscuits/heart_baunilha2.png' },
    { x: centerX - 40, y: 40, texture: '/biscuits/star_baunilha1.png' },
    { x: centerX - 40, y: 40, texture: '/biscuits/star_baunilha2.png' },
    { x: centerX + 50, y: 55, texture: '/biscuits/flower_baunilha1.png' },
    { x: centerX - 60, y: 65, texture: '/biscuits/heart_baunilha1.png' },
    { x: centerX - 40, y: 40, texture: '/biscuits/star_baunilha2.png' },
    { x: centerX + 50, y: 55, texture: '/biscuits/flower_baunilha1.png' },
    { x: centerX - 60, y: 65, texture: '/biscuits/heart_baunilha1.png' },
    { x: centerX - 40, y: 40, texture: '/biscuits/star_baunilha2.png' },
    { x: centerX + 50, y: 55, texture: '/biscuits/flower_baunilha1.png' },
  ];
  
  const biscuits = [];
  
  for (let i = 0; i < defaultPositions.length; i++) {
    const defaultPos = defaultPositions[i];
    const savedState = savedStates && savedStates[i];
    
    // Use saved position if available, otherwise use default
    const x = savedState ? savedState.x * canvasWidth : defaultPos.x;
    const y = savedState ? savedState.y * canvasHeight : defaultPos.y;

    const biscuit = createStandardBiscuit(Matter, x, y, defaultPos.texture);
    
    // Restore velocity and rotation if saved
    if (savedState && !useDefaultPositions) {
      Matter.Body.setVelocity(biscuit, { 
        x: savedState.velocityX * 0.8, // Dampen velocity slightly
        y: savedState.velocityY * 0.8 
      });
      Matter.Body.setAngle(biscuit, savedState.angle);
      Matter.Body.setAngularVelocity(biscuit, savedState.angularVelocity * 0.8);
    }
    
    biscuits.push(biscuit);
  }
  
  // Clear saved states after use
  (window as any).homeBiscuitStates = null;
  
  console.log(`üéØ Created ${biscuits.length} biscuits with ${savedStates ? 'restored' : 'default'} positions`);
  
  return biscuits;
}

function setupHomePhysicsInteraction(canvas: HTMLCanvasElement, engine: any) {
  const Matter = (window as any).Matter;
  const Mouse = Matter.Mouse;
  const MouseConstraint = Matter.MouseConstraint;
  const World = Matter.World;
  
  // Create mouse/touch input
  const mouse = Mouse.create(canvas);
  
  // Create mouse constraint for dragging
  const mouseConstraint = MouseConstraint.create(engine, {
    mouse: mouse,
    constraint: {
      stiffness: 0.05,
      damping: 0.1,
      length: 0,
      render: { visible: false }
    }
  });
  
  // Add mouse constraint to world
  World.add(engine.world, mouseConstraint);
  
  let scrollTimeout: any;
  function handleScroll() {
    canvas.style.pointerEvents = "none";
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {
      canvas.style.pointerEvents = "auto";
    }, 200);
  }
    
  canvas.addEventListener("wheel", handleScroll);

  mouseConstraint.mouse.element.removeEventListener('wheel', mouseConstraint.mouse.mousewheel);
  mouseConstraint.mouse.element.removeEventListener('DOMMouseScroll', mouseConstraint.mouse.mousewheel);

  // Store mouse constraint globally for cleanup
  (window as any).homePhysicsMouseConstraint = mouseConstraint;
  
  // State variables for drag protection
  let isDragging = false;
  let mouseDownInCanvas = false;
  
  // Function to enable drag protection (only prevent HTML interference)
  const enableDragProtection = () => {
    if (!isDragging) {
      isDragging = true;
      document.body.classList.add('drag-mode');
      
      // Disable pointer events on home-content during drag
      const homeContent = document.querySelector('.home-content') as HTMLElement;
      if (homeContent) {
        homeContent.style.pointerEvents = 'none';
      }
      
      console.log('üîí Drag protection enabled');
    }
  };
  
  // Function to disable drag protection
  const disableDragProtection = () => {
    if (isDragging) {
      isDragging = false;
      document.body.classList.remove('drag-mode');
      
      // Re-enable pointer events on home-content after drag
      const homeContent = document.querySelector('.home-content') as HTMLElement;
      if (homeContent) {
        homeContent.style.pointerEvents = '';
      }
      
      // Ensure Matter.js constraint is fully released
      if (mouseConstraint.body !== null) {
        mouseConstraint.body = null;
        mouseConstraint.pointA = null;
        mouseConstraint.pointB = null;
      }
      
      console.log('üîì Drag protection disabled');
    }
  };
  
  // Canvas mouse/touch event handlers
  const handleCanvasMouseDown = () => {
    mouseDownInCanvas = true;
    // Check if we're actually dragging an object after a short delay
    setTimeout(() => {
      if (mouseDownInCanvas && mouseConstraint.body) {
        enableDragProtection();
      }
    }, 50);
  };
  
  const handleCanvasMouseUp = () => {
    mouseDownInCanvas = false;
    
    // Force release any current drag in Matter.js
    if (mouseConstraint.body !== null) {
      mouseConstraint.body = null;
      mouseConstraint.pointA = null;
      mouseConstraint.pointB = null;
    }
    
    disableDragProtection();
  };
  
  const handleCanvasTouchStart = () => {
    mouseDownInCanvas = true;
    // Check if we're actually dragging an object after a short delay
    setTimeout(() => {
      if (mouseDownInCanvas && mouseConstraint.body) {
        enableDragProtection();
      }
    }, 50);
  };
  
  const handleCanvasTouchEnd = () => {
    mouseDownInCanvas = false;
    
    // Force release any current drag in Matter.js
    if (mouseConstraint.body !== null) {
      mouseConstraint.body = null;
      mouseConstraint.pointA = null;
      mouseConstraint.pointB = null;
    }
    
    disableDragProtection();
  };
  
  // Global event handlers for when mouse leaves canvas during drag
  const handleGlobalMouseMove = (e: MouseEvent) => {
    const homeSection = document.querySelector('.home.active');
    if (!homeSection || !isDragging || !mouseConstraint.body) {
      return; // Deixar comportamento normal
    }

    if (isDragging && mouseConstraint.body) {
      // Continue updating mouse position when dragging outside canvas
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Keep mouse position updated for Matter.js
      mouse.position.x = x;
      mouse.position.y = y;
    }
  };
  
  const handleGlobalMouseUp = () => {
    const homeSection = document.querySelector('.home.active');
    if (!homeSection || !isDragging || !mouseConstraint.body) {
      return; // Deixar comportamento normal
    }

    mouseDownInCanvas = false;
    
    // Force release any current drag in Matter.js when mouse released anywhere
    if (mouseConstraint.body !== null) {
      mouseConstraint.body = null;
      mouseConstraint.pointA = null;
      mouseConstraint.pointB = null;
    }
    
    disableDragProtection();
  };
  
  const handleGlobalTouchMove = (e: TouchEvent) => {
    const homeSection = document.querySelector('.home.active');
    if (!homeSection || !isDragging || !mouseConstraint.body || e.touches.length === 0) {
      return; // Deixar comportamento normal
    }

    if (isDragging && mouseConstraint.body && e.touches.length > 0) {
      const rect = canvas.getBoundingClientRect();
      const x = e.touches[0].clientX - rect.left;
      const y = e.touches[0].clientY - rect.top;
      
      mouse.position.x = x;
      mouse.position.y = y;
    }
  };
  
  const handleGlobalTouchEnd = () => {
    const homeSection = document.querySelector('.home.active');
    if (!homeSection || !isDragging || !mouseConstraint.body) {
      return; // Deixar comportamento normal
    }

    mouseDownInCanvas = false;
    
    // Force release any current drag in Matter.js when touch ends anywhere
    if (mouseConstraint.body !== null) {
      mouseConstraint.body = null;
      mouseConstraint.pointA = null;
      mouseConstraint.pointB = null;
    }
    
    disableDragProtection();
  };
  
  // Add canvas-specific event listeners
  canvas.addEventListener('mousedown', handleCanvasMouseDown, { passive: true });
  canvas.addEventListener('mouseup', handleCanvasMouseUp, { passive: true });
  canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: true });
  canvas.addEventListener('touchend', handleCanvasTouchEnd, { passive: true });
  canvas.addEventListener('touchcancel', handleCanvasTouchEnd, { passive: true });
  
  // Add global event listeners for drag continuation outside canvas
  document.addEventListener('mousemove', handleGlobalMouseMove, { passive: true });
  document.addEventListener('mouseup', handleGlobalMouseUp, { passive: true });
  document.addEventListener('touchmove', handleGlobalTouchMove, { passive: true });
  document.addEventListener('touchend', handleGlobalTouchEnd, { passive: true });
  document.addEventListener('touchcancel', handleGlobalTouchEnd, { passive: true });
  
  // Store cleanup function
  (window as any).homeDragCleanup = () => {
    // Remove canvas listeners
    canvas.removeEventListener('mousedown', handleCanvasMouseDown);
    canvas.removeEventListener('mouseup', handleCanvasMouseUp);
    canvas.removeEventListener('touchstart', handleCanvasTouchStart);
    canvas.removeEventListener('touchend', handleCanvasTouchEnd);
    canvas.removeEventListener('touchcancel', handleCanvasTouchEnd);
    
    // Remove global listeners
    document.removeEventListener('mousemove', handleGlobalMouseMove);
    document.removeEventListener('mouseup', handleGlobalMouseUp);
    document.removeEventListener('touchmove', handleGlobalTouchMove);
    document.removeEventListener('touchend', handleGlobalTouchEnd);
    document.removeEventListener('touchcancel', handleGlobalTouchEnd);
    
    disableDragProtection();
  };
  
  // Prevent context menu on canvas
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());
  
  console.log('üéÆ Home physics interaction setup complete');
}

// Home Canvas Resize Handler
function setupHomeCanvasResize() {
  let resizeTimeout: number;
  
  const handleResize = () => {
    // Skip resize if we're in the middle of a touch interaction
    if ((window as any).homeTouchActive) {
      console.log('üì± Skipping resize during touch interaction');
      return;
    }
    
    // Only resize if home section is active and canvas exists
    const canvas = document.getElementById('homePhysicsCanvas') as HTMLCanvasElement;
    const homeSection = document.querySelector('.home.active');
    const container = document.getElementById('homeImageContainer') as HTMLElement;
    
    if (!canvas || !homeSection || !container) {
      return;
    }
    
    // Get stored canvas size (initialized when physics world is created)
    const lastCanvasSize = (window as any).homeLastCanvasSize || { width: 0, height: 0 };
    
    // Check if size actually changed to prevent unnecessary resize on mobile interactions
    const containerRect = container.getBoundingClientRect();
    const currentWidth = Math.round(containerRect.width);
    const currentHeight = Math.round(containerRect.height);
    
    // Calculate percentage change instead of absolute pixels for better responsiveness
    const widthChange = lastCanvasSize.width > 0 ? Math.abs(currentWidth - lastCanvasSize.width) / lastCanvasSize.width : 1;
    const heightChange = lastCanvasSize.height > 0 ? Math.abs(currentHeight - lastCanvasSize.height) / lastCanvasSize.height : 1;
    
    // Only proceed if size changed by more than 5% or more than 30px (significant change)
    const significantChange = widthChange > 0.05 || heightChange > 0.05 || 
                             Math.abs(currentWidth - lastCanvasSize.width) > 30 || 
                             Math.abs(currentHeight - lastCanvasSize.height) > 30;
    
    if (!significantChange) {
      console.log('üì± Size change not significant enough, ignoring resize event', {
        widthChange: Math.round(widthChange * 100) + '%',
        heightChange: Math.round(heightChange * 100) + '%'
      });
      return;
    }
    
    console.log('üìè Size changed from', lastCanvasSize, 'to', { width: currentWidth, height: currentHeight });
    
    // Update stored size
    (window as any).homeLastCanvasSize = { width: currentWidth, height: currentHeight };
    
    // Debounce the resize to avoid too many calls (longer delay for mobile)
    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const debounceDelay = isMobile ? 500 : 300; // Longer delay on mobile to avoid interaction conflicts
    
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      console.log('üîÑ Resizing home physics canvas...');
      
      // Save biscuit positions before cleanup (for smoother transitions)
      let biscuitStates: any[] = [];
      if ((window as any).homePhysicsBiscuits && (window as any).homePhysicsBiscuits.length > 0) {
        biscuitStates = (window as any).homePhysicsBiscuits.map((biscuit: any) => ({
          x: biscuit.position.x / lastCanvasSize.width, // Normalize to percentage
          y: biscuit.position.y / lastCanvasSize.height,
          velocityX: biscuit.velocity.x,
          velocityY: biscuit.velocity.y,
          angle: biscuit.angle,
          angularVelocity: biscuit.angularVelocity
        }));
        console.log('üíæ Saved positions of', biscuitStates.length, 'biscuits');
      }
      
      // Store for use in recreation
      (window as any).homeBiscuitStates = biscuitStates;
      
      // Cleanup existing physics world
      if ((window as any).homePhysicsEngine) {
        const Matter = (window as any).Matter;
        
        // Stop the engine
        Matter.Engine.clear((window as any).homePhysicsEngine);
        
        // Stop and cleanup renderer
        if ((window as any).homePhysicsRender) {
          Matter.Render.stop((window as any).homePhysicsRender);
          (window as any).homePhysicsRender = null;
        }
        
        // Clean up mouse constraint
        if ((window as any).homePhysicsMouseConstraint) {
          Matter.World.remove((window as any).homePhysicsEngine.world, (window as any).homePhysicsMouseConstraint);
          (window as any).homePhysicsMouseConstraint = null;
        }
        
        // Clean up drag system
        if ((window as any).homeDragCleanup) {
          (window as any).homeDragCleanup();
          (window as any).homeDragCleanup = null;
        }
        
        (window as any).homePhysicsEngine = null;
        (window as any).homePhysicsBiscuits = null;
      }
      
      // Recreate physics world with new dimensions (but don't setup resize again)
      const originalSetup = (window as any).homeResizeSetup;
      (window as any).homeResizeSetup = true; // Prevent recursive setup
      createHomePhysicsWorld();
      (window as any).homeResizeSetup = originalSetup;
      
    }, debounceDelay); // Wait longer on mobile to avoid interaction conflicts
  };
  
  // Cleanup any existing resize listener first
  if ((window as any).homeResizeCleanup) {
    (window as any).homeResizeCleanup();
  }
  
  // Add resize and orientation change listeners
  window.addEventListener('resize', handleResize);
  
  // Add orientation change listener for better mobile support
  const handleOrientationChange = () => {
    // Wait a bit for the orientation change to complete
    setTimeout(() => {
      console.log('üì± Orientation changed, triggering layout update');
      handleResize();
    }, 150);
  };
  
  // Modern browsers
  if ('onorientationchange' in window) {
    window.addEventListener('orientationchange', handleOrientationChange);
  }
  
  // Also listen for screen orientation changes (newer API)
  if (screen && screen.orientation) {
    screen.orientation.addEventListener('change', handleOrientationChange);
  }
  
  // Store cleanup function globally
  (window as any).homeResizeCleanup = () => {
    window.removeEventListener('resize', handleResize);
    if ('onorientationchange' in window) {
      window.removeEventListener('orientationchange', handleOrientationChange);
    }
    if (screen && screen.orientation) {
      screen.orientation.removeEventListener('change', handleOrientationChange);
    }
    if (resizeTimeout) {
      clearTimeout(resizeTimeout);
    }
  };
  
  console.log('üìê Home canvas resize and orientation listeners setup complete');
}